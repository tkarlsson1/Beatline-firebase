<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NOTESTREAM v0.600_test</title>
<style>
  :root {
    --bg: #0b0f12;
    --panel: rgba(255,255,255,.06);
    --panel2: rgba(255,255,255,.12);
    --txt: #fff;
    --accent: #ffcc00;
    --blue: #00a0ff;
    --card-w: 96px;
    --gap: 12px;
  }
  html,body { margin:0; height:100%; background: var(--bg); color: var(--txt); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  #app { padding: 14px; display:flex; flex-direction:column; gap:14px; }
  .topbar { display:flex; justify-content:space-between; gap:10px; align-items:center; }
  .badge { background: rgba(0,0,0,.5); padding:.45rem .7rem; border:1px solid rgba(255,255,255,.2); border-radius:999px; }
  .legend { display:flex; gap:10px; align-items:center; opacity:.9; }
  .dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
  .dot.active { background: var(--accent); }
  .dot.oppo { background: var(--blue); }
  .dot.placed { background: #ccc; }

  .token-panel { display:flex; gap:8px; align-items:center; }
  .pill { padding:.3rem .6rem; border-radius:999px; border:1px solid rgba(255,255,255,.25); }

  .controls { display:flex; gap:10px; flex-wrap:wrap; }
  .controls button { padding:.55rem .9rem; border-radius:8px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.06); color:#fff; cursor:pointer; }
  .controls button:hover { background: rgba(255,255,255,.12); }

  .stage { display:flex; flex-direction:column; gap:12px; }
  .panel { background: rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:12px; }

  .row { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
  .prompt { display:none; gap:8px; align-items:center; }
  .prompt.active { display:flex; }
  .timer { font-variant-numeric: tabular-nums; }

  .timeline-wrap { overflow:auto; }
  .timeline { display:flex; align-items:center; gap: var(--gap); padding: 8px; }
  .card { width: var(--card-w); height: calc(var(--card-w)*1.5); background:#111; border:1px solid rgba(255,255,255,.15); border-radius:12px; display:flex; align-items:center; justify-content:center; box-shadow: 0 4px 10px rgba(0,0,0,.25); }
  .card.start { background: #032934; border-color:#0b939c; font-weight:700; }
  .card .year-vert { transform: rotate(-90deg); transform-origin:center; font-weight:700; letter-spacing:.5px; }
  .ghost-gap { width:0; height: calc(var(--card-w)*1.5); transition: width .12s ease; display:flex; align-items:center; justify-content:center; }
  .ghost-gap.active { width: calc(var(--card-w) + var(--gap)); }
  .ghost { width: var(--card-w); height: calc(var(--card-w)*1.5); border:2px dashed rgba(255,255,255,.6); border-radius:12px; opacity:.35; }

  .marker-active { outline: 3px solid var(--accent); outline-offset: -3px; }
  .marker-oppo { outline: 3px solid var(--blue); outline-offset: -3px; }

  .dnd-card { width:140px; height:84px; background:#222; border:2px solid #666; border-radius:12px; display:flex; align-items:center; justify-content:center; cursor:grab; user-select:none; box-shadow: 0 10px 22px rgba(0,0,0,.35); }
  .dnd-card.dragging { opacity:.85; cursor:grabbing; transform: scale(1.02); }
  .dnd-palette { display:flex; gap:12px; align-items:center; }

  /* Mini timeline ~30% */
  .mini .timeline { transform: scale(.3); transform-origin: left top; }
  .mini { height: calc((var(--card-w)*1.5) * .3 + 24px); overflow:hidden; }

  @media (orientation: portrait) {
    .hint { text-align:center; opacity:.8; }
  }
</style>
</head>
<body>
<div id="app">
  <div class="topbar">
    <div class="badge">TestlÃ¤ge (DnD) â€“ <strong>PROTOTYP</strong></div>
    <div class="legend">
      <span class="dot active"></span> Aktivas lÃ¥sta
      <span class="dot oppo"></span> Opponents fÃ¶rslag
      <span class="dot placed"></span> Placerade
    </div>
    <div class="token-panel">
      <span>Tokens A: <span id="tokA" class="pill">4</span></span>
      <button id="tokAplus">+1</button>
      <span style="margin-left:8px;">Tokens B: <span id="tokB" class="pill">4</span></span>
      <button id="tokBplus">+1</button>
    </div>
  </div>

  <div class="stage">
    <div class="controls">
      <button id="btnNext">NÃ¤sta lÃ¥t</button>
      <button id="btnReroll">Byt lÃ¥t (âˆ’1 token)</button>
      <button id="btnLock" disabled>LÃ¥s in</button>
      <button id="btnReveal" disabled>Reveal</button>
      <button id="btnNextTurn" disabled>NÃ¤sta tur</button>
      <span id="phaseLabel" class="badge"></span>
    </div>

    <div class="panel">
      <div class="row">
        <strong>Aktivt lag: <span id="activeTeamName">Team A</span></strong>
        <div class="prompt" id="oppPrompt">
          <span>Opponera?</span>
          <button id="btnOppYes">Ja (âˆ’1)</button>
          <button id="btnOppNo">Nej</button>
          <span class="timer" id="promptTimer"></span>
        </div>
        <div class="prompt" id="oppDnD">
          <span>Opposition DnD</span>
          <button id="btnOppLock">LÃ¥s opponering</button>
          <span class="timer" id="oppTimer"></span>
        </div>
      </div>

      <div class="timeline-wrap">
        <div class="timeline" id="activeTimeline"></div>
      </div>

      <div class="dnd-palette" id="palette">
        <div id="songCard" class="dnd-card" draggable="true">ðŸŽµ LÃ¥t-kort</div>
        <span id="hintText" class="hint">Dra kortet till rÃ¤tt mellanrum</span>
      </div>
    </div>

    <div class="panel mini">
      <strong>Min tidslinje (Team B â€“ mini)</strong>
      <div class="timeline-wrap">
        <div class="timeline" id="miniTimeline"></div>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const $ = (id) => document.getElementById(id);
  // Teams
  let teamA = { name:'Team A', tokens:4, years:[1978, 1984, 1992, 2001] };
  let teamB = { name:'Team B', tokens:4, years:[1969, 1988] };
  let activeTeam = 'A';

  // State
  let phase = 'idle'; // listening|locked|prompt|opposition|reveal|resolve
  let placedSlotIndex = null;     // active team's chosen slot
  let opponentWants   = false;
  let opponentSlotIndex = null;
  let dragging = false;
  let currentHoverIndex = null;
  let currentTrackYear = null;

  // DOM
  const activeTimeline = $('activeTimeline');
  const miniTimeline   = $('miniTimeline');
  const songCard       = $('songCard');
  const phaseLabel     = $('phaseLabel');
  const oppPrompt      = $('oppPrompt');
  const oppDnD         = $('oppDnD');
  const promptTimerEl  = $('promptTimer');
  const oppTimerEl     = $('oppTimer');
  const activeTeamName = $('activeTeamName');
  const hintText       = $('hintText');

  // Controls
  $('btnNext').addEventListener('click', startRound);
  $('btnReroll').addEventListener('click', doReroll);
  $('btnLock').addEventListener('click', lockPlacement);
  $('btnReveal').addEventListener('click', doReveal);
  $('btnNextTurn').addEventListener('click', nextTurn);
  $('btnOppYes').addEventListener('click', () => beginOpposition(true));
  $('btnOppNo').addEventListener('click', () => beginOpposition(false));
  $('btnOppLock').addEventListener('click', () => { if (phase==='opposition' && opponentWants && opponentSlotIndex!==null) doReveal(); });
  $('tokAplus').addEventListener('click', ()=> { teamA.tokens++; updateTokens(); });
  $('tokBplus').addEventListener('click', ()=> { teamB.tokens++; updateTokens(); });

  // Helpers
  const yearsFor = (team)=> (team==='A'?teamA.years:teamB.years).slice().sort((a,b)=>a-b);
  const other    = (team)=> team==='A' ? 'B' : 'A';
  const teamObj  = (team)=> team==='A' ? teamA : teamB;

  function renderTimeline(container, years, highlightIndex=null, marks={}){
    container.innerHTML = '';
    // StartÃ¥r-kort
    container.appendChild(makeCard('StartÃ¥r', true));
    const ys = years.slice().sort((a,b)=>a-b);
    // Build: gap(0), card(y0), gap(1), card(y1) ...
    for (let i=0;i<=ys.length;i++){
      container.appendChild(makeGap(i, highlightIndex, marks));
      if (i<ys.length) container.appendChild(makeCard(ys[i]));
    }
  }

  function makeCard(val, isStart=false){
    const d = document.createElement('div');
    d.className = 'card' + (isStart ? ' start' : '');
    const lab = document.createElement('div');
    lab.className = 'year-vert';
    lab.textContent = val;
    d.appendChild(lab);
    return d;
  }

  function makeGap(i, highlightIndex, marks){
    const g = document.createElement('div');
    g.className = 'ghost-gap' + (i===highlightIndex ? ' active' : '');
    // markers
    if (marks.active === i) g.classList.add('marker-active');
    if (marks.oppo   === i) g.classList.add('marker-oppo');
    const ghost = document.createElement('div');
    ghost.className = 'ghost';
    g.appendChild(ghost);
    g.dataset.slotIndex = i;
    return g;
  }

  function renderAll(){
    const actYears = yearsFor(activeTeam);
    const marks = {
      active: (['locked','prompt','opposition','reveal','resolve'].includes(phase) ? placedSlotIndex : null),
      oppo: (phase==='opposition' || phase==='reveal' || phase==='resolve') ? opponentSlotIndex : null
    };
    renderTimeline(activeTimeline, actYears, dragging ? currentHoverIndex : null, marks);
    renderTimeline(miniTimeline, yearsFor(other(activeTeam)), null, {});
    activeTeamName.textContent = teamObj(activeTeam).name;
    updateTokens(); updateControls();
  }

  function updateTokens(){ $('tokA').textContent = teamA.tokens; $('tokB').textContent = teamB.tokens; }
  function updateControls(){
    $('btnLock').disabled    = (placedSlotIndex===null || phase!=='listening');
    $('btnReveal').disabled  = !(['prompt','opposition','locked'].includes(phase));
    $('btnNextTurn').disabled= (phase!=='resolve');
    $('btnReroll').disabled  = (phase!=='listening' || teamObj(activeTeam).tokens<=0);
    phaseLabel.textContent   = 'Fas: ' + phase;
  }

  // Flow
  function startRound(){
    phase='listening'; placedSlotIndex=null; opponentWants=false; opponentSlotIndex=null;
    currentHoverIndex=null; currentTrackYear = mockRandomYear();
    hintText.textContent='Dra kortet till rÃ¤tt mellanrum';
    showCard(true);
    oppPrompt.classList.remove('active'); oppDnD.classList.remove('active');
    renderAll();
  }

  function doReroll(){
    const t = teamObj(activeTeam); if (t.tokens<=0) return;
    t.tokens--; currentTrackYear = mockRandomYear();
    hintText.textContent='Ny lÃ¥t dragen (âˆ’1 token). Dra igen.'; updateTokens();
  }

  function lockPlacement(){
    if (placedSlotIndex===null) return;
    phase='locked'; renderAll(); startPromptCountdown();
  }

  // 5s prompt (auto reveal pÃ¥ No/all)
  let promptTimer=null, promptRemaining=0;
  function startPromptCountdown(){
    promptRemaining=5; oppPrompt.classList.add('active'); promptTimerEl.textContent=` ${promptRemaining}s`;
    if (promptTimer) clearInterval(promptTimer);
    promptTimer = setInterval(()=>{
      promptRemaining--; promptTimerEl.textContent=` ${promptRemaining}s`;
      if (promptRemaining<=0){ clearInterval(promptTimer); beginOpposition(false); }
    },1000);
  }

  function beginOpposition(yes){
    oppPrompt.classList.remove('active');
    if (promptTimer) clearInterval(promptTimer);
    if (yes){
      const oppTeam = other(activeTeam);
      if (teamObj(oppTeam).tokens<=0){ opponentWants=false; phase='prompt'; doReveal(); return; }
      teamObj(oppTeam).tokens--; opponentWants=true; phase='opposition';
      startOppCountdown(); oppDnD.classList.add('active');
      hintText.textContent='MotstÃ¥ndare: dra din markÃ¶r (blÃ¥) till vald slot och LÃ¥s opponering';
    } else {
      opponentWants=false; phase='prompt'; doReveal(); return;
    }
    updateTokens(); updateControls();
  }

  // 30s opposition
  let oppTimer=null, oppRemaining=0;
  function startOppCountdown(){
    oppRemaining=30; oppTimerEl.textContent=` ${oppRemaining}s`;
    if (oppTimer) clearInterval(oppTimer);
    oppTimer = setInterval(()=>{
      oppRemaining--; oppTimerEl.textContent=` ${oppRemaining}s`;
      if (oppRemaining<=0){ clearInterval(oppTimer); doReveal(); }
    },1000);
  }

  function doReveal(){
    phase='reveal'; oppDnD.classList.remove('active');
    const actOK = isCorrectSlot(yearsFor(activeTeam), placedSlotIndex, currentTrackYear);
    const oppOK = opponentWants ? isCorrectSlot(yearsFor(activeTeam), opponentSlotIndex, currentTrackYear) : false;
    if (actOK){
      commitToTimeline(activeTeam, currentTrackYear);
      hintText.textContent = `Facit: ${currentTrackYear}. Aktiva korrekt (eller lika) â€“ lÃ¥ten stannar.`;
    } else if (opponentWants && oppOK){
      commitToTimeline(other(activeTeam), currentTrackYear);
      hintText.textContent = `Facit: ${currentTrackYear}. Opponent korrekt â€“ tar lÃ¥ten.`;
    } else {
      commitToTimeline(activeTeam, currentTrackYear);
      hintText.textContent = `Facit: ${currentTrackYear}. Ingen rÃ¤tt â€“ aktiva vinner tvisten.`;
    }
    phase='resolve'; updateControls(); renderAll();
  }

  function nextTurn(){
    if (teamA.years.length>=11){ alert('Team A nÃ¥r 11!'); return; }
    if (teamB.years.length>=11){ alert('Team B nÃ¥r 11!'); return; }
    activeTeam = other(activeTeam); startRound();
  }

  function commitToTimeline(team, year){
    const t = teamObj(team); t.years.push(year); t.years.sort((a,b)=>a-b);
  }

  // DnD (mouse + touch)
  songCard.addEventListener('dragstart', (e)=>{
    if (!(phase==='listening' || phase==='opposition')) { e.preventDefault(); return; }
    dragging=true; songCard.classList.add('dragging');
    if (e.dataTransfer && e.dataTransfer.setDragImage){
      const img = new Image(); img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWP4////GQAJFQMc6zL2sQAAAABJRU5ErkJggg==';
      e.dataTransfer.setDragImage(img,0,0);
    }
  });
  songCard.addEventListener('dragend', ()=>{
    dragging=false; songCard.classList.remove('dragging');
    if (phase==='listening') placedSlotIndex = currentHoverIndex;
    else if (phase==='opposition') opponentSlotIndex = currentHoverIndex;
    updateControls(); renderAll();
  });
  activeTimeline.addEventListener('dragover', (e)=>{
    if (!dragging) return;
    e.preventDefault();
    const x = e.clientX;
    const idx = nearestIndexByMidpoint(x);
    if (idx!==null){ currentHoverIndex = idx; renderAll(); }
  });

  function attachTouchDrag(el){
    let down=false;
    el.addEventListener('touchstart',(e)=>{
      if (!(phase==='listening' || phase==='opposition')) return;
      down=true; dragging=true; el.classList.add('dragging');
    },{passive:true});
    el.addEventListener('touchmove',(e)=>{
      if (!down) return;
      const t = e.touches[0];
      const idx = nearestIndexByMidpoint(t.clientX);
      if (idx!==null){ currentHoverIndex = idx; renderAll(); }
    },{passive:true});
    el.addEventListener('touchend',()=>{
      if (!down) return;
      down=false; dragging=false; el.classList.remove('dragging');
      if (phase==='listening') placedSlotIndex = currentHoverIndex;
      else if (phase==='opposition') opponentSlotIndex = currentHoverIndex;
      updateControls(); renderAll();
    },{passive:true});
  }
  attachTouchDrag(songCard);

  function nearestIndexByMidpoint(x){
    // Find ghost-gap centers in activeTimeline
    const gaps = activeTimeline.querySelectorAll('.ghost-gap');
    let bestIdx=null, bestDist=Infinity;
    gaps.forEach((g, i)=>{
      const r = g.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const d = Math.abs(x - cx);
      if (d < bestDist){ bestDist = d; bestIdx = i; }
    });
    return bestIdx;
  }

  function isCorrectSlot(sortedYears, slotIndex, Y){
    if (slotIndex===null || slotIndex===undefined) return false;
    if (sortedYears.length===0){ return true; } // mot StartÃ¥r
    if (slotIndex===0) return Y <= sortedYears[0];
    if (slotIndex===sortedYears.length) return Y >= sortedYears[sortedYears.length-1];
    const left = sortedYears[slotIndex-1], right=sortedYears[slotIndex];
    return (left <= Y && Y <= right);
  }
  function mockRandomYear(){ return 1960 + Math.floor(Math.random()*61); }

  // Init
  renderAll();
})();
</script>
</body>
</html>
