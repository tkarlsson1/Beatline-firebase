<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NOTESTREAM v0.603_test</title>
<style>
  :root {
    --bg: #0b0f12;
    --txt: #fff;
    --accent: #ffcc00;
    --blue: #00a0ff;
    --card-w: 96px;   /* computed to fit 10 cards + 1 gap */
    --gap: 12px;      /* computed */
  }
  html,body { margin:0; height:100%; background: var(--bg); color: var(--txt); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  #app { padding: 14px; display:flex; flex-direction:column; gap:14px; }
  .topbar { display:flex; justify-content:space-between; gap:10px; align-items:center; }
  .badge { background: rgba(0,0,0,.5); padding:.45rem .7rem; border:1px solid rgba(255,255,255,.2); border-radius:999px; }
  .legend { display:flex; gap:10px; align-items:center; opacity:.9; }
  .dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
  .dot.active { background: var(--accent); }
  .dot.oppo { background: var(--blue); }
  .dot.placed { background: #ccc; }

  .token-panel { display:flex; gap:8px; align-items:center; }
  .pill { padding:.3rem .6rem; border-radius:999px; border:1px solid rgba(255,255,255,.25); }

  .controls { display:flex; gap:10px; flex-wrap:wrap; }
  .controls button { padding:.55rem .9rem; border-radius:8px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.06); color:#fff; cursor:pointer; }
  .controls button:hover { background: rgba(255,255,255,.12); }

  .stage { display:flex; flex-direction:column; gap:12px; }
  .panel { background: rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:12px; }

  .row { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
  .prompt { display:none; gap:8px; align-items:center; }
  .prompt.active { display:flex; }
  .timer { font-variant-numeric: tabular-nums; }

  .timeline-wrap { overflow:auto; }
  .timeline { display:flex; align-items:center; gap: var(--gap); padding: 8px; }
  .card { width: var(--card-w); height: calc(var(--card-w)*1.5); background:#111; border:1px solid rgba(255,255,255,.15); border-radius:12px; display:flex; align-items:center; justify-content:center; box-shadow: 0 4px 10px rgba(0,0,0,.25); position: relative; }
  .card.start { background: #032934; border-color:#0b939c; font-weight:700; }
  .card .year-vert { 
    transform: rotate(90deg);
    transform-origin:center; 
    font-weight:600; 
    letter-spacing:.4px; 
    font-size: calc(var(--card-w) * 0.58);
    line-height: 1;
    white-space: nowrap;
  }
  /* Tentative kort (aktivt lag) */
  .tentative-active { background: #2d2200; border-color: var(--accent); }
  /* Tentative kort (opponent) */
  .tentative-oppo { background: #001f33; border-color: var(--blue); }

  /* Gap utan "streck": vi anv√§nder gapen som beh√•llare f√∂r ev. tentative-card */
  .ghost-gap { width:0; height: calc(var(--card-w)*1.5); display:flex; align-items:center; justify-content:center; }
  .ghost-gap.active { width: var(--card-w); }

  .dnd-card { width:140px; height:84px; background:#222; border:2px solid #666; border-radius:12px; display:flex; align-items:center; justify-content:center; cursor:grab; user-select:none; box-shadow: 0 10px 22px rgba(0,0,0,.35); }
  .dnd-card.dragging { opacity:.85; cursor:grabbing; transform: scale(1.02); }
  .dnd-palette { display:flex; gap:12px; align-items:center; }

  /* Mini timeline ~30% */
  .mini .timeline { transform: scale(.3); transform-origin: left top; }
  .mini { height: calc((var(--card-w)*1.5) * .3 + 24px); overflow:hidden; }

  @media (orientation: portrait) {
    .hint { text-align:center; opacity:.8; }
  }
</style>
</head>
<body>
<div id="app">
  <div class="topbar">
    <div class="badge">Testl√§ge (DnD) ‚Äì <strong>PROTOTYP v0.603</strong></div>
    <div class="legend">
      <span class="dot active"></span> Aktivas val
      <span class="dot oppo"></span> Opponentens val
      <span class="dot placed"></span> Placerade
    </div>
    <div class="token-panel">
      <span>Tokens A: <span id="tokA" class="pill">4</span></span>
      <button id="tokAplus">+1</button>
      <span style="margin-left:8px;">Tokens B: <span id="tokB" class="pill">4</span></span>
      <button id="tokBplus">+1</button>
    </div>
  </div>

  <div class="stage">
    <div class="controls">
      <button id="btnNext">N√§sta l√•t</button>
      <button id="btnReroll">Byt l√•t (‚àí1 token)</button>
      <button id="btnLock" disabled>L√•s in</button>
      <button id="btnReveal" disabled>Reveal</button>
      <button id="btnNextTurn" disabled>N√§sta tur</button>
      <span id="phaseLabel" class="badge"></span>
    </div>

    <div class="panel">
      <div class="row">
        <strong>Aktivt lag: <span id="activeTeamName">Team A</span></strong>
        <div class="prompt" id="oppPrompt">
          <span>Opponera?</span>
          <button id="btnOppYes">Ja (‚àí1)</button>
          <button id="btnOppNo">Nej</button>
          <span class="timer" id="promptTimer"></span>
        </div>
        <div class="prompt" id="oppDnD">
          <span>Opposition DnD</span>
          <button id="btnOppLock">L√•s opponering</button>
          <span class="timer" id="oppTimer"></span>
        </div>
      </div>

      <div class="timeline-wrap">
        <div class="timeline" id="activeTimeline"></div>
      </div>

      <div class="dnd-palette" id="palette">
        <div id="songCard" class="dnd-card" draggable="true">üéµ L√•t-kort</div>
        <span id="hintText" class="hint">Dra kortet till r√§tt mellanrum</span>
      </div>
    </div>

    <div class="panel mini">
      <strong>Min tidslinje (Team B ‚Äì mini)</strong>
      <div class="timeline-wrap">
        <div class="timeline" id="miniTimeline"></div>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const $ = (id) => document.getElementById(id);
  // Teams
  let teamA = { name:'Team A', tokens:4, years:[1978, 1984, 1992, 2001] };
  let teamB = { name:'Team B', tokens:4, years:[1969, 1988] };
  let activeTeam = 'A';

  // State
  let phase = 'idle'; // listening|locked|prompt|opposition|reveal|resolve
  let placedSlotIndex = null;     // active team's tentative slot
  let opponentWants   = false;
  let opponentSlotIndex = null;
  let dragging = false;
  let currentHoverIndex = null;
  let currentTrackYear = null;

  // DOM
  const activeTimeline = $('activeTimeline');
  const miniTimeline   = $('miniTimeline');
  const songCard       = $('songCard');
  const phaseLabel     = $('phaseLabel');
  const oppPrompt      = $('oppPrompt');
  const oppDnD         = $('oppDnD');
  const promptTimerEl  = $('promptTimer');
  const oppTimerEl     = $('oppTimer');
  const activeTeamName = $('activeTeamName');
  const hintText       = $('hintText');

  // Controls
  $('btnNext').addEventListener('click', startRound);
  $('btnReroll').addEventListener('click', doReroll);
  $('btnLock').addEventListener('click', lockPlacement);
  $('btnReveal').addEventListener('click', doReveal);
  $('btnNextTurn').addEventListener('click', nextTurn);
  $('btnOppYes').addEventListener('click', () => beginOpposition(true));
  $('btnOppNo').addEventListener('click', () => beginOpposition(false));
  $('btnOppLock').addEventListener('click', () => { if (phase==='opposition' && opponentWants && opponentSlotIndex!==null) doReveal(); });
  $('tokAplus').addEventListener('click', ()=> { teamA.tokens++; updateTokens(); });
  $('tokBplus').addEventListener('click', ()=> { teamB.tokens++; updateTokens(); });
  window.addEventListener('resize', computeCardLayout);
  window.addEventListener('orientationchange', computeCardLayout);

  // Helpers
  const yearsFor = (team)=> (team==='A'?teamA.years:teamB.years).slice().sort((a,b)=>a-b);
  const other    = (team)=> team==='A' ? 'B' : 'A';
  const teamObj  = (team)=> team==='A' ? teamA : teamB;

  function makeCard(val, classes=''){
    const d = document.createElement('div');
    d.className = 'card ' + classes;
    const lab = document.createElement('div');
    lab.className = 'year-vert';
    lab.textContent = val;
    d.appendChild(lab);
    return d;
  }

  function makeGap(i, activeTentativeIdx, oppTentativeIdx, hoverIdx, inOpposition){
    const g = document.createElement('div');
    g.className = 'ghost-gap';
    g.dataset.slotIndex = i;

    // Determine if gap should be visually active (reserve width)
    if (i === hoverIdx || i === activeTentativeIdx || (inOpposition && i === oppTentativeIdx)) {
      g.classList.add('active');
    }

    // Insert tentative cards *inside* the gap so width is controlled
    if (activeTentativeIdx !== null && i === activeTentativeIdx) {
      g.appendChild(makeCard('?', 'tentative-active'));
    }
    if (inOpposition && oppTentativeIdx !== null && i === oppTentativeIdx) {
      // If both tentative occupy same gap, stack vertically (simple)
      const c = makeCard('?', 'tentative-oppo');
      c.style.position = (activeTentativeIdx === i) ? 'absolute' : 'static';
      if (activeTentativeIdx === i) { c.style.transform = 'translateY(8px)'; }
      g.style.position = 'relative';
      g.appendChild(c);
    }
    return g;
  }

  function renderTimeline(container, years, inOpposition){
    container.innerHTML = '';
    // Start√•r-kort
    const start = makeCard('Start√•r', 'start');
    container.appendChild(start);

    const ys = years.slice().sort((a,b)=>a-b);
    for (let i=0;i<=ys.length;i++){
      const gap = makeGap(i, placedSlotIndex, opponentSlotIndex, dragging ? currentHoverIndex : null, inOpposition);
      container.appendChild(gap);
      if (i<ys.length) container.appendChild(makeCard(String(ys[i])));
    }
  }

  function renderAll(){
    computeCardLayout(); // ensure sizes fit 10 kort + 1 gap
    renderTimeline(activeTimeline, yearsFor(activeTeam), phase==='opposition');
    renderTimeline(miniTimeline, yearsFor(other(activeTeam)), false);
    activeTeamName.textContent = teamObj(activeTeam).name;
    updateTokens(); updateControls();
  }

  function updateTokens(){ $('tokA').textContent = teamA.tokens; $('tokB').textContent = teamB.tokens; }
  function updateControls(){
    $('btnLock').disabled    = (placedSlotIndex===null || phase!=='listening');
    $('btnReveal').disabled  = !(['prompt','opposition','locked'].includes(phase));
    $('btnNextTurn').disabled= (phase!=='resolve');
    $('btnReroll').disabled  = (phase!=='listening' || teamObj(activeTeam).tokens<=0);
    phaseLabel.textContent   = 'Fas: ' + phase;
  }

  // Layout: fit 10 cards + 11 gaps
  function computeCardLayout(){
    const wrap = activeTimeline.closest('.timeline-wrap');
    if (!wrap) return;
    const w = wrap.clientWidth || window.innerWidth;
    const padding = 24; // approx panel padding
    const maxW = 140, minW = 56;
    let bestCard = 96, bestGap = 12;
    for (let cw = maxW; cw >= minW; cw -= 1) {
      const gap = Math.max(8, Math.round(cw * 0.12));
      const total = 10*cw + 11*gap; // 10 kort + 11 gaps
      if (total <= (w - padding)) { bestCard = cw; bestGap = gap; break; }
    }
    document.documentElement.style.setProperty('--card-w', bestCard + 'px');
    document.documentElement.style.setProperty('--gap', bestGap + 'px');
  }

  // Flow
  function startRound(){
    phase='listening'; placedSlotIndex=null; opponentWants=false; opponentSlotIndex=null;
    currentHoverIndex=null; currentTrackYear = mockRandomYear();
    hintText.textContent='Dra kortet till r√§tt mellanrum';
    showCard(true);
    oppPrompt.classList.remove('active'); oppDnD.classList.remove('active');
    renderAll();
  }

  function doReroll(){
    const t = teamObj(activeTeam); if (t.tokens<=0) return;
    t.tokens--; currentTrackYear = mockRandomYear();
    hintText.textContent='Ny l√•t dragen (‚àí1 token). Dra igen.'; updateTokens();
  }

  function lockPlacement(){
    if (placedSlotIndex===null) return;
    phase='locked'; renderAll(); startPromptCountdown();
  }

  // 5s prompt (auto reveal p√• No/all)
  let promptTimer=null, promptRemaining=0;
  function startPromptCountdown(){
    promptRemaining=5; oppPrompt.classList.add('active'); promptTimerEl.textContent=` ${promptRemaining}s`;
    if (promptTimer) clearInterval(promptTimer);
    promptTimer = setInterval(()=>{
      promptRemaining--; promptTimerEl.textContent=` ${promptRemaining}s`;
      if (promptRemaining<=0){ clearInterval(promptTimer); beginOpposition(false); }
    },1000);
  }

  function beginOpposition(yes){
    oppPrompt.classList.remove('active');
    if (promptTimer) clearInterval(promptTimer);
    if (yes){
      const oppTeam = other(activeTeam);
      if (teamObj(oppTeam).tokens<=0){ opponentWants=false; phase='prompt'; doReveal(); return; }
      teamObj(oppTeam).tokens--; opponentWants=true; phase='opposition';
      startOppCountdown(); oppDnD.classList.add('active');
      hintText.textContent='Motst√•ndare: dra din mark√∂r (bl√•) till vald slot och L√•s opponering';
    } else {
      opponentWants=false; phase='prompt'; doReveal(); return;
    }
    updateTokens(); updateControls();
  }

  // 30s opposition
  let oppTimer=null, oppRemaining=0;
  function startOppCountdown(){
    oppRemaining=30; oppTimerEl.textContent=` ${oppRemaining}s`;
    if (oppTimer) clearInterval(oppTimer);
    oppTimer = setInterval(()=>{
      oppRemaining--; oppTimerEl.textContent=` ${oppRemaining}s`;
      if (oppRemaining<=0){ clearInterval(oppTimer); doReveal(); }
    },1000);
  }

  function doReveal(){
    phase='reveal'; oppDnD.classList.remove('active');
    const actOK = isCorrectSlot(yearsFor(activeTeam), placedSlotIndex, currentTrackYear);
    const oppOK = opponentWants ? isCorrectSlot(yearsFor(activeTeam), opponentSlotIndex, currentTrackYear) : false;

    if (actOK){
      commitToTimeline(activeTeam, currentTrackYear);
      hintText.textContent = `Facit: ${currentTrackYear}. Aktiva korrekt (eller lika) ‚Äì l√•ten stannar.`;
    } else if (opponentWants && oppOK){
      commitToTimeline(other(activeTeam), currentTrackYear);
      hintText.textContent = `Facit: ${currentTrackYear}. Opponent korrekt ‚Äì tar l√•ten.`;
    } else {
      commitToTimeline(activeTeam, currentTrackYear);
      hintText.textContent = `Facit: ${currentTrackYear}. Ingen r√§tt ‚Äì aktiva vinner tvisten.`;
    }

    // Viktigt: ta bort tentative-mark√∂rer efter reveal s√• gula/bl√• "gissa-kortet" inte ligger kvar
    placedSlotIndex = null;
    opponentSlotIndex = null;

    phase='resolve'; updateControls(); renderAll();
  }

  function nextTurn(){
    if (teamA.years.length>=11){ alert('Team A n√•r 11!'); return; }
    if (teamB.years.length>=11){ alert('Team B n√•r 11!'); return; }
    activeTeam = other(activeTeam); startRound();
  }

  function commitToTimeline(team, year){
    const t = teamObj(team); t.years.push(year); t.years.sort((a,b)=>a-b);
  }

  // DnD (mouse + touch)
  songCard.addEventListener('dragstart', (e)=>{
    if (!(phase==='listening' || phase==='opposition')) { e.preventDefault(); return; }
    dragging=true; songCard.classList.add('dragging');
    if (e.dataTransfer && e.dataTransfer.setDragImage){
      const img = new Image(); img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWP4////GQAJFQMc6zL2sQAAAABJRU5ErkJggg==';
      e.dataTransfer.setDragImage(img,0,0);
    }
  });
  songCard.addEventListener('dragend', ()=>{
    dragging=false; songCard.classList.remove('dragging');
    if (phase==='listening') placedSlotIndex = currentHoverIndex;
    else if (phase==='opposition') opponentSlotIndex = currentHoverIndex;
    updateControls(); renderAll();
  });
  activeTimeline.addEventListener('dragover', (e)=>{
    if (!dragging) return;
    e.preventDefault();
    const x = e.clientX;
    const idx = nearestIndexByMidpoint(x);
    if (idx!==null){ currentHoverIndex = idx; renderAll(); }
  });

  function attachTouchDrag(el){
    let down=false;
    el.addEventListener('touchstart',(e)=>{
      if (!(phase==='listening' || phase==='opposition')) return;
      down=true; dragging=true; el.classList.add('dragging');
    },{passive:true});
    el.addEventListener('touchmove',(e)=>{
      if (!down) return;
      const t = e.touches[0];
      const idx = nearestIndexByMidpoint(t.clientX);
      if (idx!==null){ currentHoverIndex = idx; renderAll(); }
    },{passive:true});
    el.addEventListener('touchend',()=>{
      if (!down) return;
      down=false; dragging=false; el.classList.remove('dragging');
      if (phase==='listening') placedSlotIndex = currentHoverIndex;
      else if (phase==='opposition') opponentSlotIndex = currentHoverIndex;
      updateControls(); renderAll();
    },{passive:true});
  }
  attachTouchDrag(songCard);

  function nearestIndexByMidpoint(x){
    // index 0..N of ghost gaps
    const gaps = activeTimeline.querySelectorAll('.ghost-gap');
    let bestIdx=null, bestDist=Infinity;
    gaps.forEach((g, i)=>{
      const r = g.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const d = Math.abs(x - cx);
      if (d < bestDist){ bestDist = d; bestIdx = i; }
    });
    return bestIdx;
  }

  function isCorrectSlot(sortedYears, slotIndex, Y){
    if (slotIndex===null || slotIndex===undefined) return false;
    if (sortedYears.length===0){ return true; } // mot Start√•r
    if (slotIndex===0) return Y <= sortedYears[0];
    if (slotIndex===sortedYears.length) return Y >= sortedYears[sortedYears.length-1];
    const left = sortedYears[slotIndex-1], right=sortedYears[slotIndex];
    return (left <= Y && Y <= right);
  }
  function mockRandomYear(){ return 1960 + Math.floor(Math.random()*61); }

  // Init
  computeCardLayout();
  renderAll();
})();
</script>
</body>
</html>
