<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NOTESTREAM v0.605_test</title>
<style>
  :root {
    --bg: #0b0f12;
    --txt: #fff;
    --card-w: 96px;
    --gap: 12px;
    /* lagf√§rger */
    --team1: #ffcc00; /* gul */
    --team2: #00a0ff; /* bl√• */
    --team3: #ff4d5a; /* r√∂d */
  }
  html,body { margin:0; height:100%; background: var(--bg); color: var(--txt); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  #app { padding: 14px; display:flex; flex-direction:column; gap:14px; }
  .topbar { display:flex; justify-content:space-between; gap:10px; align-items:center; }
  .badge { background: rgba(0,0,0,.5); padding:.45rem .7rem; border:1px solid rgba(255,255,255,.2); border-radius:999px; }
  .legend { display:flex; gap:12px; align-items:center; opacity:.9; }
  .legend .chip { display:flex; align-items:center; gap:6px; padding:.2rem .5rem; border:1px solid rgba(255,255,255,.2); border-radius:999px; background:rgba(255,255,255,.05); }
  .dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
  .dot.t1 { background: var(--team1); }
  .dot.t2 { background: var(--team2); }
  .dot.t3 { background: var(--team3); }

  .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .controls button { padding:.55rem .9rem; border-radius:8px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.06); color:#fff; cursor:pointer; }
  .controls button:hover { background: rgba(255,255,255,.12); }

  .stage { display:flex; flex-direction:column; gap:12px; }
  .panel { background: rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:12px; }

  .row { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; gap:8px; }
  .prompt { display:none; gap:8px; align-items:center; flex-wrap:wrap; }
  .prompt.active { display:flex; }
  .timer { font-variant-numeric: tabular-nums; }

  .timeline-wrap { overflow:auto; }
  .timeline { display:flex; align-items:center; gap: var(--gap); padding: 8px; }
  .card { width: var(--card-w); height: calc(var(--card-w)*1.5); background:#111; border:1px solid rgba(255,255,255,.15); border-radius:12px; display:flex; align-items:center; justify-content:center; box-shadow: 0 4px 10px rgba(0,0,0,.25); position: relative; }
  .card .year-vert { 
    transform: rotate(90deg);
    transform-origin:center; 
    font-weight:600; 
    letter-spacing:.4px; 
    font-size: calc(var(--card-w) * 0.58);
    line-height: 1; white-space: nowrap;
  }
  /* Tentative-kort i gapen (per lagf√§rg) */
  .tentative.t1 { background: #2d2200; border-color: var(--team1); }
  .tentative.t2 { background: #001f33; border-color: var(--team2); }
  .tentative.t3 { background: #2a0a0e; border-color: var(--team3); }

  /* Gap container: vi visar bara bredd n√§r hover/markerad */
  .ghost-gap { width:0; height: calc(var(--card-w)*1.5); display:flex; align-items:center; justify-content:center; position:relative; }
  .ghost-gap.active { width: var(--card-w); }

  .mini .timeline { transform: scale(.3); transform-origin: left top; }
  .mini { height: calc((var(--card-w)*1.5) * .3 + 24px); overflow:hidden; }
</style>
</head>
<body>
<div id="app">
  <div class="topbar">
    <div class="badge">Testl√§ge ‚Äì <strong>PROTOTYP v0.605</strong></div>
    <div class="legend">
      <span class="chip"><span class="dot t1"></span>Lag 1</span>
      <span class="chip"><span class="dot t2"></span>Lag 2</span>
      <span class="chip"><span class="dot t3"></span>Lag 3</span>
    </div>
  </div>

  <div class="stage">
    <div class="controls">
      <button id="btnNext">N√§sta l√•t</button>
      <button id="btnReroll">Byt l√•t (‚àí1 token)</button>
      <button id="btnLock" disabled>L√•s in</button>
      <button id="btnReveal" disabled>Reveal</button>
      <button id="btnNextTurn" disabled>N√§sta tur</button>
      <span id="phaseLabel" class="badge"></span>
      <span id="startBadge" class="badge"></span>
    </div>

    <div class="panel">
      <div class="row">
        <strong>Aktivt lag: <span id="activeTeamName">Lag 1</span></strong>
        <div class="prompt" id="oppPrompt">
          <span>Opponera?</span>
          <div id="oppButtons" style="display:flex; gap:6px; flex-wrap:wrap;"></div>
          <button id="btnOppNo">Ingen</button>
          <span class="timer" id="promptTimer"></span>
        </div>
        <div class="prompt" id="oppDnD">
          <span>Opposition DnD</span>
          <button id="btnOppLock">L√•s opponering</button>
          <span class="timer" id="oppTimer"></span>
        </div>
      </div>

      <div class="timeline-wrap">
        <div class="timeline" id="activeTimeline"></div>
      </div>

      <div class="dnd-palette" id="palette">
        <div id="songCard" class="dnd-card" draggable="true">üéµ L√•t-kort</div>
        <span id="hintText" class="hint">Dra kortet till r√§tt mellanrum</span>
      </div>
    </div>

    <div class="panel mini">
      <strong>Min tidslinje (N√§sta lag ‚Äì mini)</strong>
      <div class="timeline-wrap">
        <div class="timeline" id="miniTimeline"></div>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const $ = (id) => document.getElementById(id);

  // === Mock konfig f√∂r start√•r (ers√§tts senare av poolens min/max) ===
  const MOCK_MIN_YEAR = 1955;
  const MOCK_MAX_YEAR = 2023;
  const randInt = (a,b)=> a + Math.floor(Math.random()*(b-a+1));

  // === Tre lag med f√§rger ===
  const teams = [
    { id:1, name:'Lag 1', color:'var(--team1)', tokens:4, years:[] },
    { id:2, name:'Lag 2', color:'var(--team2)', tokens:4, years:[] },
    { id:3, name:'Lag 3', color:'var(--team3)', tokens:4, years:[] },
  ];
  let activeIdx = 0; // roterar 0->1->2->0...
  let startYear = null;
  let gameOver = false;

  // === State ===
  let phase = 'idle'; // listening|locked|prompt|opposition|reveal|resolve|gameover
  let placedSlotIndex = null;        // aktivas tentativ
  let opponentTeamIdx = null;        // vilket lag (index) opponerar
  let opponentSlotIndex = null;      // opponen¬≠tens tentativ
  let dragging = false;
  let currentHoverIndex = null;
  let currentTrackYear = null;

  // === DOM ===
  const activeTimeline = $('activeTimeline');
  const miniTimeline   = $('miniTimeline');
  const songCard       = $('songCard');
  const phaseLabel     = $('phaseLabel');
  const oppPrompt      = $('oppPrompt');
  const oppButtons     = $('oppButtons');
  const oppDnD         = $('oppDnD');
  const promptTimerEl  = $('promptTimer');
  const oppTimerEl     = $('oppTimer');
  const activeTeamName = $('activeTeamName');
  const hintText       = $('hintText');
  const startBadge     = $('startBadge');

  const btnNext        = $('btnNext');
  const btnReroll      = $('btnReroll');
  const btnLock        = $('btnLock');
  const btnReveal      = $('btnReveal');
  const btnNextTurn    = $('btnNextTurn');
  const btnOppNo       = $('btnOppNo');
  const btnOppLock     = $('btnOppLock');

  // === Events ===
  btnNext.addEventListener('click', startRound);
  btnReroll.addEventListener('click', doReroll);
  btnLock.addEventListener('click', lockPlacement);
  btnReveal.addEventListener('click', doReveal);
  btnNextTurn.addEventListener('click', nextTurn);
  btnOppNo.addEventListener('click', () => beginOpposition(null));
  btnOppLock.addEventListener('click', () => { if (phase==='opposition' && opponentTeamIdx!==null && opponentSlotIndex!==null) doReveal(); });
  window.addEventListener('resize', computeCardLayout);
  window.addEventListener('orientationchange', computeCardLayout);

  // === Helpers ===
  const otherIdxs = ()=> teams.map((_,i)=>i).filter(i => i!==activeIdx);
  const yearsFor  = (idx)=> teams[idx].years.slice().sort((a,b)=>a-b);
  const nextIdx   = (i)=> (i+1) % teams.length;

  function teamColorClass(idx){ return idx===0?'t1': idx===1?'t2':'t3'; }
  function teamColorValue(idx){ return getComputedStyle(document.documentElement).getPropertyValue(idx===0?'--team1':idx===1?'--team2':'--team3'); }

  function makeCard(val, classes=''){
    const d = document.createElement('div');
    d.className = 'card ' + classes;
    const lab = document.createElement('div');
    lab.className = 'year-vert';
    lab.textContent = val;
    d.appendChild(lab);
    return d;
  }

  function makeGap(i, showActive, showOpp, hoverIdx){
    const g = document.createElement('div');
    g.className = 'ghost-gap';
    g.dataset.slotIndex = i;
    if (i === hoverIdx || i === showActive || i === showOpp) g.classList.add('active');

    if (showActive !== null && i === showActive){
      g.appendChild(makeCard('?', 'tentative ' + teamColorClass(activeIdx)));
    }
    if (showOpp !== null && i === showOpp){
      const c = makeCard('?', 'tentative ' + teamColorClass(opponentTeamIdx));
      if (showActive === showOpp){ // enkel stack vid samma gap
        c.style.position = 'absolute'; c.style.transform = 'translateY(8px)'; g.style.position = 'relative';
      }
      g.appendChild(c);
    }
    return g;
  }

  function renderTimeline(container, years, inOpposition){
    container.innerHTML = '';

    // Bygg ordning: sorterat inkl. startYear i korrekt position (som ett vanligt kort)
    const ys = years.slice().sort((a,b)=>a-b);
    const ordered = insertSorted(ys, startYear);

    for (let i=0;i<=ordered.length;i++){
      const g = makeGap(i, placedSlotIndex, inOpposition ? opponentSlotIndex : null, dragging ? currentHoverIndex : null);
      container.appendChild(g);
      if (i < ordered.length){
        const y = ordered[i];
        container.appendChild(makeCard(String(y)));
      }
    }
  }

  function insertSorted(arr, x){
    const out = arr.slice();
    let pos = out.findIndex(v => x <= v);
    if (pos === -1) out.push(x);
    else out.splice(pos, 0, x);
    return out;
  }

  function renderAll(){
    computeCardLayout();
    renderTimeline(activeTimeline, yearsFor(activeIdx), phase==='opposition');
    // mini visar n√§sta lags tidslinje
    renderTimeline(miniTimeline, yearsFor(nextIdx(activeIdx)), false);
    activeTeamName.textContent = teams[activeIdx].name;
    startBadge.textContent = startYear ? ('Start√•r: ' + startYear) : '';

    // Opponera-knappar
    oppButtons.innerHTML = '';
    otherIdxs().forEach(i => {
      const b = document.createElement('button');
      b.textContent = `${teams[i].name} (‚àí1)`;
      b.style.borderColor = 'rgba(255,255,255,.2)';
      b.style.background = 'rgba(255,255,255,.06)';
      b.style.color = '#fff';
      b.onclick = ()=> beginOpposition(i);
      // disable if no tokens
      if (teams[i].tokens <= 0) { b.disabled = true; b.style.opacity = .5; }
      oppButtons.appendChild(b);
    });

    updateTokensAndControls();
  }

  function updateTokensAndControls(){
    phaseLabel.textContent = 'Fas: ' + phase + (gameOver ? ' (slut)' : '');
    btnLock.disabled    = (placedSlotIndex===null || phase!=='listening' || gameOver);
    btnReveal.disabled  = !(['prompt','opposition','locked'].includes(phase)) || gameOver;
    btnNextTurn.disabled= (phase!=='resolve') || gameOver;
    btnReroll.disabled  = (phase!=='listening' || teams[activeIdx].tokens<=0 || gameOver);
    btnNext.disabled    = gameOver;
  }

  function computeCardLayout(){
    const wrap = activeTimeline.closest('.timeline-wrap');
    if (!wrap) return;
    const w = wrap.clientWidth || window.innerWidth;
    const padding = 24;
    const maxW = 140, minW = 56;
    let bestCard = 96, bestGap = 12;
    for (let cw = maxW; cw >= minW; cw -= 1) {
      const gap = Math.max(8, Math.round(cw * 0.12));
      const total = 10*cw + 11*gap;
      if (total <= (w - padding)) { bestCard = cw; bestGap = gap; break; }
    }
    document.documentElement.style.setProperty('--card-w', bestCard + 'px');
    document.documentElement.style.setProperty('--gap', bestGap + 'px');
  }

  // === Fl√∂de ===
  function startRound(){
    if (gameOver) return;
    if (startYear === null){ startYear = randInt(MOCK_MIN_YEAR, MOCK_MAX_YEAR); }
    phase='listening'; placedSlotIndex=null; opponentTeamIdx=null; opponentSlotIndex=null;
    currentHoverIndex=null; currentTrackYear = mockRandomYear();
    hintText.textContent='Dra kortet till r√§tt mellanrum';
    showCard(true);
    oppPrompt.classList.remove('active'); oppDnD.classList.remove('active');
    renderAll();
  }

  function doReroll(){
    const t = teams[activeIdx]; if (t.tokens<=0 || gameOver) return;
    t.tokens--; currentTrackYear = mockRandomYear();
    hintText.textContent='Ny l√•t dragen (‚àí1 token). Dra igen.'; updateTokensAndControls();
  }

  function lockPlacement(){
    if (placedSlotIndex===null || gameOver) return;
    phase='locked'; renderAll(); startPromptCountdown();
  }

  // 5s prompt (auto reveal om ingen opponerar)
  let promptTimer=null, promptRemaining=0;
  function startPromptCountdown(){
    promptRemaining=5; oppPrompt.classList.add('active'); promptTimerEl.textContent=` ${promptRemaining}s`;
    clearInterval(promptTimer);
    promptTimer = setInterval(()=>{
      promptRemaining--; promptTimerEl.textContent=` ${promptRemaining}s`;
      if (promptRemaining<=0){ clearInterval(promptTimer); beginOpposition(null); }
    },1000);
  }

  // yesTeamIdx: index f√∂r laget som opponerar, eller null om ingen
  function beginOpposition(yesTeamIdx){
    oppPrompt.classList.remove('active'); clearInterval(promptTimer);
    if (yesTeamIdx===null){
      // Ingen opponerar -> direkt reveal
      phase='prompt'; doReveal(); return;
    }
    // Kolla tokens
    if (teams[yesTeamIdx].tokens <= 0){
      // om saknar tokens: behandla som ingen opponerar
      phase='prompt'; doReveal(); return;
    }
    teams[yesTeamIdx].tokens--;
    opponentTeamIdx = yesTeamIdx;
    opponentSlotIndex = null;
    phase='opposition';
    startOppCountdown();
    oppDnD.classList.add('active');
    hintText.textContent = `${teams[yesTeamIdx].name}: dra din mark√∂r till vald slot och L√•s opponering`;
    updateTokensAndControls(); renderAll();
  }

  // 30s f√∂r oppositionsdrag
  let oppTimer=null, oppRemaining=0;
  function startOppCountdown(){
    oppRemaining=30; oppTimerEl.textContent=` ${oppRemaining}s`;
    clearInterval(oppTimer);
    oppTimer = setInterval(()=>{
      oppRemaining--; oppTimerEl.textContent=` ${oppRemaining}s`;
      if (oppRemaining<=0){ clearInterval(oppTimer); doReveal(); }
    },1000);
  }

  function doReveal(){
    if (gameOver) return;
    phase='reveal'; oppDnD.classList.remove('active');

    const ordered = insertSorted(yearsFor(activeIdx), startYear);
    const actOK = isCorrectSlotAgainstOrdered(ordered, placedSlotIndex, currentTrackYear);
    const oppOK = (opponentTeamIdx!==null) ? isCorrectSlotAgainstOrdered(ordered, opponentSlotIndex, currentTrackYear) : false;

    // Ny logik:
    // - Aktiva r√§tt => aktiva f√•r kortet (alltid)
    // - Aktiva fel  => aktiva f√•r ALDRIG kortet; om opponent √§r r√§tt => opponent f√•r kortet; annars discard
    if (actOK){
      commitToTimeline(activeIdx, currentTrackYear);
      hintText.textContent = `Facit: ${currentTrackYear}. ${teams[activeIdx].name} korrekt ‚Äì beh√•ller.`;
    } else if (opponentTeamIdx!==null && oppOK){
      commitToTimeline(opponentTeamIdx, currentTrackYear);
      hintText.textContent = `Facit: ${currentTrackYear}. ${teams[opponentTeamIdx].name} korrekt ‚Äì tar kortet.`;
    } else {
      hintText.textContent = `Facit: ${currentTrackYear}. Inget lag f√•r kortet.`;
    }

    // Rensa mark√∂rer
    placedSlotIndex = null;
    opponentSlotIndex = null;
    opponentTeamIdx = null;

    // Vinstkontroll
    if (teams[activeIdx].years.length >= 11){
      phase='gameover'; gameOver=true;
      alert(`${teams[activeIdx].name} n√•r 11! Spelet √§r slut.`);
    } else if (teams.some(t => t.years.length >= 11)){
      const winner = teams.find(t => t.years.length >= 11);
      phase='gameover'; gameOver=true;
      alert(`${winner.name} n√•r 11! Spelet √§r slut.`);
    } else {
      phase='resolve';
    }

    updateTokensAndControls(); renderAll();
  }

  function nextTurn(){
    if (gameOver) return;
    if (teams.some(t => t.years.length >= 11)){ phase='gameover'; gameOver=true; updateTokensAndControls(); return; }
    activeIdx = (activeIdx + 1) % teams.length;
    startRound();
  }

  function commitToTimeline(teamIdx, year){
    const t = teams[teamIdx];
    if (t.years.length >= 11) return; // s√§kerhetsn√§t
    t.years.push(year); t.years.sort((a,b)=>a-b);
  }

  // DnD
  songCard.addEventListener('dragstart', (e)=>{
    if (!(phase==='listening' || phase==='opposition') || gameOver) { e.preventDefault(); return; }
    dragging=true; songCard.classList.add('dragging');
    if (e.dataTransfer && e.dataTransfer.setDragImage){
      const img = new Image(); img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWP4////GQAJFQMc6zL2sQAAAABJRU5ErkJggg==';
      e.dataTransfer.setDragImage(img,0,0);
    }
  });
  songCard.addEventListener('dragend', ()=>{
    dragging=false; songCard.classList.remove('dragging');
    if (phase==='listening') placedSlotIndex = currentHoverIndex;
    else if (phase==='opposition') opponentSlotIndex = currentHoverIndex;
    updateTokensAndControls(); renderAll();
  });
  activeTimeline.addEventListener('dragover', (e)=>{
    if (!dragging || gameOver) return;
    e.preventDefault();
    const x = e.clientX;
    const idx = nearestIndexByMidpoint(x);
    if (idx!==null){ currentHoverIndex = idx; renderAll(); }
  });

  function nearestIndexByMidpoint(x){
    const gaps = activeTimeline.querySelectorAll('.ghost-gap');
    let bestIdx=null, bestDist=Infinity;
    gaps.forEach((g, i)=>{
      const r = g.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const d = Math.abs(x - cx);
      if (d < bestDist){ bestDist = d; bestIdx = i; }
    });
    return bestIdx;
  }

  function isCorrectSlotAgainstOrdered(ordered, slotIndex, Y){
    if (slotIndex===null || slotIndex===undefined) return false;
    if (ordered.length===0) return true;
    if (slotIndex===0) return Y <= ordered[0];
    if (slotIndex===ordered.length) return Y >= ordered[ordered.length-1];
    const L = ordered[slotIndex-1];
    const R = ordered[slotIndex];
    return (L <= Y && Y <= R);
  }

  function mockRandomYear(){ return randInt(1955, 2023); }

  // Init
  computeCardLayout();
  startRound();
})();
</script>
</body>
</html>
