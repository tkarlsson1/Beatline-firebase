<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="description" content="Ã…rsquiz om lÃ¥tar â€“ spela, gissa och redigera Ã¥rtal.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NOTESTREAM â€“0.626 (TEST)</title>

  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;700&display=swap" rel="stylesheet" />
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111111">

  <!-- QR code lib -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

  <style>
    :root {
      --bg: #0b0f12;
      --txt: #fff;
      --team1: #ffcc00;
      --team2: #00a0ff;
      --team3: #ff4d5a;
      --card-w: 96px;
      --card-scale: .56;
      --gap: 10px;
    }
    html, body { overflow-x:hidden; }
    body {
      font-family: 'Manrope', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: url('background.jpg') no-repeat center center fixed;
      background-size: cover;
      margin: 0; padding: 0;
      display: flex; flex-direction: column; align-items: center;
      min-height: 100vh; color: var(--txt);
    }
    .container { padding: 2rem; max-width: 900px; width: 100%; margin: 2rem 1rem; position: relative; z-index: 1; }
    .logo { display:block; margin:0 auto 1.5rem auto; max-width: 400px; height:auto; }

    /* --- Restored "pill" filter UI --- */
    #source-checkbox-container { display:flex; flex-wrap:wrap; justify-content:center; gap:1.0rem .6rem; margin-bottom:1.2rem; }
    .checkbox-pill { position:relative; display:inline-block; }
    .checkbox-pill input[type="checkbox"]{ display:none; }
    .checkbox-pill label{ cursor:pointer; padding:.55rem .8rem; border:3px solid #032934; border-radius:12px; background:#032934; color:#fff; transition:.2s; font-size:1rem; }
    .checkbox-pill input[type="checkbox"]:checked + label{ background:#0b939c; border-color:#0b939c; }
    .subheading{ display:block; width:100%; text-align:center; font-size:.9rem; color:#fff; margin:.4rem 0 .2rem 0; opacity:.9; }
    .divider { height:2px; background:rgba(255,255,255,.25); width:100%; margin:1rem 0; }
    select { padding:.5rem; font-size:1rem; background:#032934; color:#fff; border:none; border-radius:8px; }
    .start-button { background: linear-gradient(to right, #fb1820, #ff6310); border: none; border-radius: 10px; padding: 12px 24px; font-size: 18px; font-weight: bold; color: white; cursor: pointer; transition: all .2s ease-in-out; display:block; margin:0 auto; }
    .start-button:hover { transform: scale(1.03); }

    /* Cards timeline (prototype style) */
    .panel { background: rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:12px; }
    .row { display:flex; justify-content:center; align-items:center; margin-bottom:8px; gap:8px; flex-wrap:wrap; }
    .timeline-wrap { overflow:auto; }
    .timeline { display:flex; align-items:center; gap: 0; padding: 8px; justify-content: center; }
    .card { width: calc(var(--card-w)*var(--card-scale)); height: calc(var(--card-w)*var(--card-scale)*1.5); background:#111; border:1px solid rgba(255,255,255,.15); border-radius:12px; display:flex; align-items:center; justify-content:center; box-shadow: 0 4px 10px rgba(0,0,0,.25); position: relative; color:#fff; }
    .card .year-vert { transform: rotate(90deg); transform-origin:center; font-weight:700; letter-spacing:.35px; font-size: calc(var(--card-w)*var(--card-scale) * 0.58); line-height: 1; white-space: nowrap; }
    .ghost-gap { width: var(--gap); height: calc(var(--card-w)*var(--card-scale)*1.5); display:flex; align-items:center; justify-content:center; position:relative; transition: width .12s ease; flex: 0 0 auto; border: 2px dashed rgba(255,255,255,.22); border-radius:10px; opacity:.7; }
    .ghost-gap.active { width: calc(var(--card-w)*var(--card-scale)); border-color:#ffd166; background: rgba(255,209,102,.14); }
    .draggable { touch-action:none; user-select:none; -webkit-user-select:none; cursor: grab; }
    .draggable:active { cursor: grabbing; }

    .teams-strip { display:flex; justify-content:center; gap:14px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }
    .chip { display:flex; align-items:center; gap:6px; padding:.25rem .6rem; border:1px solid rgba(255,255,255,.2); border-radius:999px; background:rgba(255,255,255,.05); }
    .dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
    .t1 { background: var(--team1); } .t2 { background: var(--team2); } .t3 { background: var(--team3); }

    /* Modaler + badges */
    .modal { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; justify-content:center; align-items:center; z-index:5000; }
    .modal-content { background:#fff; padding:1.5rem; border-radius:8px; width:min(92vw, 600px); max-height:80vh; overflow:auto; box-sizing:border-box; }
    .closeBtn { color:#333; font-weight:bold; cursor:pointer; font-size:1.5rem; position:absolute; top:10px; right:20px; }
    #envBadge { position: fixed; bottom: 8px; right: 8px; background: rgba(0,0,0,.7); color: #fff; padding: 6px 10px; border-radius: 8px; font-size: 12px; z-index: 9999; pointer-events: none; }

    /* Inputs i Spotifyâ€‘import */
    .textish { width:40%; padding:.5rem; background:#032934; color:#fff; border:0; border-radius:8px; }
  </style>
</head>

<body>
  <div id="envBadge"></div>

  <!-- Inloggningsmodal -->
  <div id="loginModal" class="modal" role="dialog" aria-modal="true">
    <div class="modal-content" style="text-align:center;">
      <span class="closeBtn" id="loginClose">&times;</span>
      <h2>Logga in</h2>
      <input type="email" id="emailInput" placeholder="Eâ€‘post" style="width:80%;padding:.5rem;margin:.3rem auto;display:block;" />
      <input type="password" id="passwordInput" placeholder="LÃ¶senord" style="width:80%;padding:.5rem;margin:.3rem auto;display:block;" />
      <button id="loginButton">Logga in</button>
      <button id="showRegister" style="margin-top: .8rem;">Skapa konto</button>
    </div>
  </div>

  <!-- Registreringsmodal -->
  <div id="registerModal" class="modal" role="dialog" aria-modal="true">
    <div class="modal-content" style="text-align:center;">
      <span class="closeBtn" id="registerClose">&times;</span>
      <h2>Registrera dig</h2>
      <input type="email" id="regEmail" placeholder="Eâ€‘post" style="width:80%;padding:.5rem;margin:.3rem auto;display:block;" />
      <input type="password" id="regPassword" placeholder="LÃ¶senord" style="width:80%;padding:.5rem;margin:.3rem auto;display:block;" />
      <button id="registerButton">Registrera</button>
    </div>
  </div>

  <div class="container" id="mainContent">
    <img src="logga.png" alt="Notestream logo" class="logo" />

    <!-- Filter/Startsida (RESTORED DESIGN) -->
    <div id="filter-page">
      <div id="source-checkbox-container"></div>
      <p class="subheading">Standardlistor</p>
      <!-- Standardlistor fylls via JS -->

      <div class="divider"></div>
      <p class="subheading">Egna spellistor</p>
      <!-- Egna listor fylls via JS -->

      <div style="display:flex; justify-content:center; gap:1rem; margin-top:1rem;">
        <div style="display:flex; flex-direction:column; align-items:center;">
          <label for="startYear">FrÃ¥n Ã¥r:</label>
          <select id="startYear"></select>
        </div>
        <div style="display:flex; flex-direction:column; align-items:center;">
          <label for="endYear">Till Ã¥r:</label>
          <select id="endYear"></select>
        </div>
      </div>

      <!-- Spotify-spellisteimport -->
      <div id="spotify-import" style="margin: 1.2rem 0 1.6rem 0; text-align:center;">
        <h3>LÃ¤gg till Spotifyâ€‘spellista</h3>
        <input type="text" id="playlistLinkInput" class="textish" placeholder="Klistra in Spotifyâ€‘lÃ¤nken">
        <input type="text" id="playlistNameInput" class="textish" placeholder="Spellistans namn">
        <button id="addPlaylistButton" class="start-button" style="margin-top:.6rem;">LÃ¤gg till</button>
      </div>

      <p id="selectedSongCount" style="text-align:center;">Valda lÃ¥tar: 0</p>
      <button id="startButton" class="start-button">Starta spel</button>
      <button id="startLobbyBtn" class="start-button" style="margin-left:.5rem;">Starta i lobby</button>

    </div>

    <!-- Lobby -->
    <div id="lobby-page" style="display:none; text-align:center;">
      <h2>Lobby</h2>
      <div id="lobby-qr" class="qrcode" aria-label="QR-kod fÃ¶r att gÃ¥ med"></div>
      <p id="lobby-link" style="font-size:.9rem; word-break:break-all;"></p>
      <h3>Lag</h3>
      <div id="team-list" style="max-width:480px; margin:0 auto;"></div>
      <button id="startGameButton" class="start-button" style="margin-top:1rem;">Starta spel</button>
    </div>

    <!-- Join -->
    <div id="join-page" style="display:none; text-align:center;">
      <h2>GÃ¥ med i spel</h2>
      <input id="joinTeamName" type="text" placeholder="Lagnamn" style="width:60%; padding:.5rem; margin:.5rem auto; background:#032934; color:#fff; border:0; border-radius:6px;">
      <button id="joinSubmit" class="start-button">GÃ¥ med</button>
    </div>

    <!-- Game (prototype timeline kept) -->
    <div id="game-page" style="display:none;">
      <div class="teams-strip" id="teams-header"></div>

      <div class="panel">
        <div class="timeline-wrap">
          <div class="timeline" id="activeTimeline"></div>
        </div>

        <div class="row">
          <div id="songCard" class="chip draggable" aria-label="Dra fÃ¶r att lÃ¤gga kort">
            ðŸŽµ Dra fÃ¶r att lÃ¤gga kort
          </div>
        </div>

        <div class="row">
          <button id="btnLock" class="start-button" disabled style="padding:.5rem 1rem; font-size:1rem;">LÃ¥s in</button>
          <button id="revealButton" class="start-button" style="padding:.5rem 1rem; font-size:1rem;">Visa svar</button>
          <button id="confirmPlacementButton" class="start-button" style="padding:.5rem 1rem; font-size:1rem;">BekrÃ¤fta placering</button>
          <button id="nextSongButtonGame" class="start-button" style="padding:.5rem 1rem; font-size:1rem;">NÃ¤sta lÃ¥t</button>
        </div>
      </div>

      <div class="panel" style="margin-top:10px;">
        <div class="timeline-wrap">
          <div class="timeline" id="miniTimeline"></div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    /* ===========================
       Firebase (hardcoded RTDB)
       =========================== */
    import { initializeApp, getApp, getApps } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-app.js";
    import { getDatabase, ref, onValue, set, push, update, get } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-database.js";
    import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAfv4yGrI7Vj5PaX0A_XFRn0P4U--S9tFA",
      authDomain: "beatlinefirebase.firebaseapp.com",
      databaseURL: "https://notestreamfire.europe-west1.firebasedatabase.app",
      projectId: "beatlinefirebase",
      storageBucket: "beatlinefirebase.firebasestorage.app",
      messagingSenderId: "196231817325",
      appId: "1:196231817325:web:d5603a36a9c2c5f247f764"
    };
    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const db  = getDatabase(app, "https://notestreamfire.europe-west1.firebasedatabase.app");
    const auth = getAuth(app);
    document.getElementById("envBadge").textContent = `RTDB: https://notestreamfire.europe-west1.firebasedatabase.app`;

    /* ===========================
       State & helpers
       =========================== */
    const $ = (id)=>document.getElementById(id);
    let standardSongs = [], userPlaylistSongs = [], songs = [], sourceFilteredSongs = [], currentFilteredSongs = [], shownSongs = [];
    window.isHost = false; window.sessionId = null;
    let selectedSlotIndex = null;
    let dragging = false, activePointerId = null, currentHoverIndex = null;

    function setPage(id){ ["filter-page","lobby-page","join-page","game-page"].forEach(pid=>{$(pid).style.display=(pid===id)?"block":"none";}); }
    function joinURL(sessionId){ const url = new URL(location.href); url.searchParams.set("join", sessionId); return url.origin + url.pathname + "?" + url.searchParams.toString(); }
    function currentStartEndYears(){ return { startYear: parseInt($("startYear").value)||1950, endYear: parseInt($("endYear").value)||new Date().getFullYear() }; }

    /* ===========================
       Auth
       =========================== */
    onAuthStateChanged(auth, (user)=>{
      if (user){ $("loginModal").style.display="none"; $("registerModal").style.display="none"; initDataListeners(); maybeAutoJoinFromURL(); }
      else { $("loginModal").style.display="flex"; }
    });
    $("loginButton").addEventListener("click", ()=>{ const email=$("emailInput").value.trim(); const password=$("passwordInput").value; signInWithEmailAndPassword(auth, email, password).catch(()=>{}); });
    $("showRegister").addEventListener("click", ()=>{ $("loginModal").style.display="none"; $("registerModal").style.display="flex"; });
    $("registerButton").addEventListener("click", ()=>{ const email=$("regEmail").value.trim(); const password=$("regPassword").value; createUserWithEmailAndPassword(auth, email, password).catch(()=>{}); });

    /* ===========================
       Data listeners
       =========================== */
    function initDataListeners(){
      // Standardlistor
      onValue(ref(db, 'standardLists'), (snapshot)=>{
        standardSongs = [];
        if (snapshot.exists()) {
          const raw = snapshot.val();
          for (const playlistName in raw) {
            const playlistData = raw[playlistName];
            if (playlistData.songs) {
              for (const trackId in playlistData.songs) {
                standardSongs.push({ qr: trackId, ...playlistData.songs[trackId], source: [playlistName] });
              }
            }
          }
        }
        mergeSongs();
      });

      // Egna listor
      onAuthStateChanged(auth, (user)=>{
        if (!user) return;
        const uid = user.uid;
        onValue(ref(db, `userPlaylists/${uid}`), (snap)=>{
          userPlaylistSongs = [];
          if (snap.exists()) {
            const data = snap.val();
            for (const playlistName in data) {
              const pl = data[playlistName];
              if (pl.songs) {
                for (const trackId in pl.songs) {
                  userPlaylistSongs.push({ qr: trackId, ...pl.songs[trackId], source: [playlistName] });
                }
              }
            }
          }
          mergeSongs();
        });
      });
    }

    function mergeSongs(){
      const merged = {};
      standardSongs.forEach(s => { merged[s.qr] = { ...s, source:[...s.source] }; });
      userPlaylistSongs.forEach(s => {
        if (merged[s.qr]) merged[s.qr].source = [...new Set([...merged[s.qr].source, ...s.source])];
        else merged[s.qr] = { ...s, year: s.customYear ?? s.year, source:[...s.source] };
      });
      songs = Object.values(merged);
      populateSourceCheckboxes();
    }

    function populateSourceCheckboxes(){
      const container = $("source-checkbox-container");
      container.innerHTML = "";

      // Alla
      const allDiv = document.createElement("div");
      allDiv.className = "checkbox-pill";
      const cbAll = document.createElement("input"); cbAll.type = "checkbox"; cbAll.name="source"; cbAll.value="alla"; cbAll.id="source-alla";
      const lbAll = document.createElement("label"); lbAll.setAttribute("for","source-alla"); lbAll.textContent = "Alla lÃ¥tar";
      cbAll.addEventListener("change", function(){
        container.querySelectorAll('input[name="source"]').forEach(chk => { if (chk!==cbAll) chk.checked = cbAll.checked; });
        updateYearSelection();
      });
      allDiv.appendChild(cbAll); allDiv.appendChild(lbAll); container.appendChild(allDiv);

      const stdHeading = document.createElement("p"); stdHeading.className = "subheading"; stdHeading.textContent = "Standardlistor";
      container.appendChild(stdHeading);

      const stdSources = Array.from(new Set(standardSongs.map(s => s.source[0]))).sort();
      stdSources.forEach(source => {
        const wrap = document.createElement("div"); wrap.className = "checkbox-pill";
        const cb = document.createElement("input"); cb.type="checkbox"; cb.name="source"; cb.value=source; cb.id="std-"+source.replace(/\s+/g,'-').toLowerCase();
        const lb = document.createElement("label"); lb.setAttribute("for", cb.id); lb.textContent = source;
        cb.addEventListener("change", updateYearSelection);
        wrap.appendChild(cb); wrap.appendChild(lb); container.appendChild(wrap);
      });

      container.appendChild(document.createElement("div")).className="divider";

      const userHeading = document.createElement("p"); userHeading.className="subheading"; userHeading.textContent="Egna spellistor";
      container.appendChild(userHeading);

      const usrSources = Array.from(new Set(userPlaylistSongs.map(s => s.source[0]))).filter(x => !stdSources.includes(x)).sort();
      usrSources.forEach(source => {
        const wrap = document.createElement("div"); wrap.className = "checkbox-pill";
        const cb = document.createElement("input"); cb.type="checkbox"; cb.name="source"; cb.value=source; cb.id="usr-"+source.replace(/\s+/g,'-').toLowerCase();
        const lb = document.createElement("label"); lb.setAttribute("for", cb.id); lb.textContent = source;
        cb.addEventListener("change", updateYearSelection);
        wrap.appendChild(cb); wrap.appendChild(lb); container.appendChild(wrap);
      });

      // Ã…r-dropdowns
      const startDD = $("startYear");
      const endDD = $("endYear");
      startDD.innerHTML = ""; endDD.innerHTML = "";
      const thisYear = new Date().getFullYear();
      for (let y = 1950; y <= thisYear; y++){
        const o1 = document.createElement("option"); o1.value=y; o1.textContent=y; if (y===1950) o1.selected=true;
        const o2 = document.createElement("option"); o2.value=y; o2.textContent=y; if (y===thisYear) o2.selected=true;
        startDD.appendChild(o1); endDD.appendChild(o2);
      }
      updateSongCount();
    }

    function updateSongCount(){
      const startYear = parseInt($("startYear").value);
      const endYear   = parseInt($("endYear").value);
      const cnt = sourceFilteredSongs.filter(s => +s.year >= startYear && +s.year <= endYear).length;
      $("selectedSongCount").textContent = `Valda lÃ¥tar: ${cnt}`;
    }

    window.updateYearSelection = function(){
      const checked = Array.from(document.querySelectorAll('input[name="source"]:checked')).map(x => x.value);
      let selected = checked.includes("alla")
        ? Array.from(new Set([...new Set(standardSongs.map(s=>s.source[0])), ...new Set(userPlaylistSongs.map(s=>s.source[0])), "alla"]))
        : checked;

      sourceFilteredSongs = songs.filter(song => song.source.some(src => selected.includes(src)));
      updateSongCount();
    };

    /* Spotify-import (samma som tidigare; kan kopplas in hÃ¤r om du vill) */
    async function getBackendSpotifyToken(){
      const cached = localStorage.getItem('spotifyToken');
      const exp = +localStorage.getItem('spotifyTokenExpiry');
      if (cached && exp && Date.now() < exp) return cached;
      const r = await fetch('https://api-grl2mze3sa-uc.a.run.app/getSpotifyToken', { method:'POST' });
      if (!r.ok) return null;
      const data = await r.json();
      const token = data.access_token; const expiresIn = data.expires_in;
      localStorage.setItem('spotifyToken', token);
      localStorage.setItem('spotifyTokenExpiry', (Date.now()+expiresIn*1000-60000).toString());
      return token;
    }
    async function fetchSpotifyPlaylist(playlistUrl){
      const playlistId = playlistUrl.split("/playlist/")[1]?.split("?")[0];
      if (!playlistId) throw new Error("Ogiltig playlistâ€‘lÃ¤nk.");
      const token = await getBackendSpotifyToken();
      let tracks = {}, nextUrl = `https://api.spotify.com/v1/playlists/${playlistId}/tracks`;
      while (nextUrl){
        const resp = await fetch(nextUrl, { headers:{ Authorization:`Bearer ${token}` }});
        const data = await resp.json();
        (data.items||[]).forEach(item=>{
          const t = item.track; if (!t || !t.id) return;
          tracks[t.id] = { title: t.name, artist: t.artists.map(a=>a.name).join(", "), year: t.album.release_date?.slice(0,4) ?? "" };
        });
        nextUrl = data.next;
      }
      return tracks;
    }
    document.getElementById("addPlaylistButton").addEventListener("click", async ()=>{
      try{
        const name = $("playlistNameInput").value.trim();
        const link = $("playlistLinkInput").value.trim();
        if (!name || !link) return alert("Fyll i bÃ¥de namn och lÃ¤nk.");
        const tracks = await fetchSpotifyPlaylist(link);
        const uid = auth.currentUser?.uid;
        if (!uid) return alert("Logga in fÃ¶rst.");
        await set(ref(db, `userPlaylists/${uid}/${name}`), { songs: tracks });
        alert(`Spellistan "${name}" har lagts till.`);
      }catch(e){ console.error(e); alert("Kunde inte lÃ¤gga till spellistan."); }
    });

    /* ===========================
       Lobby / Multiplayer
       =========================== */
    window.filterSongs = function(){
      const startYear = parseInt($("startYear").value);
      const endYear   = parseInt($("endYear").value);
      currentFilteredSongs = sourceFilteredSongs.filter(s => +s.year >= startYear && +s.year <= endYear);
      shownSongs = [];
      if (!currentFilteredSongs.length){
        alert("Inga lÃ¥tar i det hÃ¤r intervallet. VÃ¤lj andra kÃ¤llor/Ã¥rtal eller lÃ¤gg till en spellista.");
        return false;
      }
      return true;
    };

    async function createSessionFromFilter(){
      if (!auth.currentUser) throw new Error("Inte inloggad.");
      const list = window.currentFilteredSongs || [];
      if (!list.length) throw new Error("Inga filtrerade lÃ¥tar.");
      const {startYear, endYear} = currentStartEndYears();

      const deck = list.map(s => s.qr);
      const songMap = {};
      list.forEach(s => {
        const yr = s.customYear ?? s.year;
        songMap[s.qr] = { title: s.title||"", artist: s.artist||"", year: yr||"" };
      });

      const sessionRef = push(ref(db, 'sessions'));
      const sid = sessionRef.key;
      await set(sessionRef, {
        createdAt: Date.now(),
        status: "lobby",
        hostId: auth.currentUser.uid,
        settings: { startYear, endYear },
        songMap,
        deck,
        shown: {},
        current: null,
        teams: {},
        turn: { order: [], activeIndex: 0 }
      });
      window.sessionId = sid;
      window.isHost = true;
      localStorage.setItem("sessionId", sid);
      localStorage.setItem("role", "host");
      return sid;
    }

    function renderLobbyTeams(session){
      const list = $("team-list");
      list.innerHTML = "";
      const teams = session.teams ? Object.entries(session.teams) : [];
      if (!teams.length) list.innerHTML = "<p>Inga lag Ã¤nnu â€“ scanna QR och gÃ¥ med.</p>";
      teams.forEach(([tid, t])=>{
        const item = document.createElement("div");
        item.style.padding=".4rem .6rem"; item.style.marginBottom=".3rem"; item.style.background="rgba(3,41,52,.6)"; item.style.color="#fff"; item.style.borderRadius="8px";
        item.textContent = `${t.name}` + (t.score ? ` â€¢ ${t.score}p` : "");
        list.appendChild(item);
      });
    }

    function listenToSession(sid){
      onValue(ref(db, `sessions/${sid}`), snap => {
        if (!snap.exists()) return;
        const session = snap.val();
        renderLobbyTeams(session);
        if (session.status === "lobby"){
          setPage("lobby-page");
        } else {
          renderGame(session);
          setPage("game-page");
        }
      });
    }

    function showLobby(sid){
      setPage("lobby-page");
      window.sessionId = sid;
      window.isHost = true;

      const q = $("lobby-qr");
      q.innerHTML = "";
      new QRCode(q, { text: joinURL(sid), width: 160, height: 160 });
      $("lobby-link").textContent = joinURL(sid);

      const btn = $("startGameButton");
      if (!btn._bound){
        btn._bound = true;
        btn.addEventListener("click", async ()=>{
          try{ await startGameHost(); }catch(e){ alert("Kunde inte starta spelet."); }
        });
      }
      listenToSession(sid);
    }

    function showJoinPage(sid){
      setPage("join-page");
      window.sessionId = sid;
      window.isHost = false;
      localStorage.setItem("role","player");
      const btn = $("joinSubmit");
      if (!btn._bound){
        btn._bound = true;
        btn.addEventListener("click", async ()=>{
          const name = ($("joinTeamName").value||"").trim();
          if (!name) return alert("Ange lagnamn.");
          const teamRef = push(ref(db, `sessions/${sid}/teams`));
          const teamId = teamRef.key;
          await set(teamRef, { name, tokens: 3, score: 0, timeline: [] });
          localStorage.setItem("teamId", teamId);
          listenToSession(sid);
        });
      }
    }

    function maybeAutoJoinFromURL(){
      const p = new URLSearchParams(location.search);
      const sid = p.get("join");
      if (!sid) return;
      if (localStorage.getItem("sessionId") === sid){ listenToSession(sid); return; }
      showJoinPage(sid);
    }

    async function startGameHost(){
      const sid = window.sessionId;
      const teamsSnap = await get(ref(db, `sessions/${sid}/teams`));
      const teams = teamsSnap.val() || {};
      const order = Object.keys(teams);
      if (!order.length) return alert("Minst ett lag krÃ¤vs.");

      const sessSnap = await get(ref(db, `sessions/${sid}`));
      const sess = sessSnap.val();
      const deck = sess.deck || [];
      const shown = sess.shown || {};
      const nextId = deck.find(id => !shown[id]);
      if (!nextId) return alert("Deck tomt.");

      const updates = {};
      updates[`sessions/${sid}/status`] = "playing";
      updates[`sessions/${sid}/turn`] = { order, activeIndex: 0 };
      updates[`sessions/${sid}/current`] = { trackId: nextId, revealed: false };
      updates[`sessions/${sid}/shown/${nextId}`] = true;
      await update(ref(db), updates);
    }

    /* ===========================
       Game (prototype timeline kept)
       =========================== */
    function yearsForTeam(session, tid){
      const t = session.teams?.[tid];
      const arr = (t?.timeline||[]).map(x => parseInt(x.year)||0).filter(Boolean);
      return arr.slice().sort((a,b)=>a-b);
    }
    function orderFor(session){ return (session.turn && session.turn.order) || Object.keys(session.teams||{}); }
    function activeIdxFor(session){ return (session.turn && typeof session.turn.activeIndex==='number') ? session.turn.activeIndex : 0; }
    function activeTidFor(session){ const ord=orderFor(session); return ord[activeIdxFor(session)] || null; }

    function computeCardLayout(container){
      const wrap = container.closest('.timeline-wrap'); if (!wrap) return;
      const w = wrap.clientWidth || window.innerWidth; const padding = 24;
      const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-scale')) || 0.56;
      const maxBase = 140, minBase = 56;
      let bestBase = 96, bestGap = 10;
      for (let base=maxBase; base>=minBase; base--){
        const cw = base * scale, gap = Math.max(6, Math.round(cw*0.12));
        const total = 10*cw + 11*gap; // heuristik
        if (total <= (w - padding)) { bestBase = base; bestGap = gap; break; }
      }
      document.documentElement.style.setProperty('--card-w', bestBase + 'px');
      document.documentElement.style.setProperty('--gap', bestGap + 'px');
    }
    function makeCard(year){ const d=document.createElement('div'); d.className='card'; const lab=document.createElement('div'); lab.className='year-vert'; lab.textContent=year; d.appendChild(lab); return d; }
    function makeGap(i){ const g=document.createElement('div'); g.className='ghost-gap'; g.dataset.slotIndex=i; if (i===currentHoverIndex) g.classList.add('active'); return g; }

    function renderTeamsHeader(session){
      const wrap = $("teams-header"); wrap.innerHTML="";
      const ord = orderFor(session); const actIdx = activeIdxFor(session);
      ord.forEach((tid, idx)=>{
        const t = session.teams[tid];
        const chip = document.createElement("div"); chip.className="chip"; chip.style.background = idx===actIdx ? "rgba(11,147,156,.65)" : "rgba(255,255,255,.05)";
        const dot = document.createElement("span"); dot.className="dot " + (idx===0?'t1':idx===1?'t2':'t3');
        const label = document.createElement("span"); label.textContent = `${t.name} â€¢ ${t.score||0}p â€¢ ðŸ”¥${t.tokens??3}`;
        chip.appendChild(dot); chip.appendChild(label); wrap.appendChild(chip);
      });
    }

    function renderTimelines(session){
      const actTid = activeTidFor(session); if (!actTid) return;
      const ys = yearsForTeam(session, actTid);
      const activeContainer = $("activeTimeline"), miniContainer = $("miniTimeline");
      computeCardLayout(activeContainer); computeCardLayout(miniContainer);

      activeContainer.innerHTML="";
      for (let i=0;i<=ys.length;i++){
        activeContainer.appendChild(makeGap(i));
        if (i<ys.length) activeContainer.appendChild(makeCard(String(ys[i])));
      }

      miniContainer.innerHTML="";
      const ord = orderFor(session); const nextIdx = (activeIdxFor(session)+1) % ord.length; const nextTid = ord[nextIdx];
      const ysNext = yearsForTeam(session, nextTid);
      for (let i=0;i<=ysNext.length;i++){
        miniContainer.appendChild(makeGap(-1));
        if (i<ysNext.length) miniContainer.appendChild(makeCard(String(ysNext[i])));
      }
    }

    function renderGame(session){
      renderTeamsHeader(session);
      renderTimelines(session);
      wireGameControls(session);
    }

    function nearestIndexByMidpoint(container, x){
      const gaps = Array.from(container.querySelectorAll('.ghost-gap'));
      let bestIdx=null, bestDist=Infinity;
      gaps.forEach((g,i)=>{
        const r = g.getBoundingClientRect(); const cx = r.left + r.width/2; const d = Math.abs(x - cx);
        if (d < bestDist){ bestDist=d; bestIdx=i; }
      });
      return bestIdx;
    }

    function wireGameControls(session){
      const isHost = (window.isHost === true);
      const activeContainer = $("activeTimeline");
      const songCard = $("songCard");
      const btnLock = $("btnLock");
      const revealBtn = $("revealButton");
      const confirmBtn = $("confirmPlacementButton");
      const nextBtn = $("nextSongButtonGame");

      btnLock.disabled = (selectedSlotIndex===null);

      if (isHost){
        function startDrag(e){
          dragging=true; activePointerId = e.pointerId;
          try { e.target.setPointerCapture && e.target.setPointerCapture(activePointerId); } catch(_){}
          window.addEventListener('pointermove', onMove);
          window.addEventListener('pointerup', endDrag, { once:true });
          window.addEventListener('pointercancel', cancelDrag, { once:true });
          onMove(e);
        }
        function onMove(e){
          if (!dragging || e.pointerId!==activePointerId) return;
          const x = e.clientX; const idx = nearestIndexByMidpoint(activeContainer, x);
          if (idx!==null){ currentHoverIndex = idx; selectedSlotIndex = idx; btnLock.disabled = false; renderTimelines(session); }
        }
        function endDrag(_e){ dragging=false; activePointerId=null; }
        function cancelDrag(_e){ dragging=false; activePointerId=null; }

        songCard.onpointerdown = startDrag;
        activeContainer.onpointermove = (e)=>{ if (dragging) onMove(e); };

        btnLock.onclick = async ()=>{
          await confirmPlacementHandler();
          selectedSlotIndex = null; currentHoverIndex = null; btnLock.disabled = true;
        };
        revealBtn.onclick = async ()=>{
          const sid = window.sessionId; const curSnap = await get(ref(db, `sessions/${sid}/current`)); if (!curSnap.exists()) return;
          await update(ref(db, `sessions/${sid}/current`), { revealed: true });
        };
        confirmBtn.onclick = async ()=>{
          await confirmPlacementHandler();
          selectedSlotIndex = null; currentHoverIndex = null; btnLock.disabled = true;
        };
        nextBtn.onclick = hostNextSong;
      } else {
        songCard.onpointerdown = null; btnLock.disabled = true;
        revealBtn.onclick = null; confirmBtn.onclick = null; nextBtn.onclick = null;
      }
    }

    /* Helpers + confirm handler (same as earlier fixed version) */
    function getActiveTeamInfo(session){
      const order = (session.turn && session.turn.order) || [];
      const idx = (session.turn && typeof session.turn.activeIndex === 'number') ? session.turn.activeIndex : 0;
      const activeTid = order[idx];
      const activeTeam = activeTid ? session.teams?.[activeTid] : null;
      return { activeTid, activeTeam, activeIndex: idx };
    }
    function sortTimelineByYear(tl){ const a=(tl||[]).slice(); a.sort((x,y)=>(parseInt(x.year)||0)-(parseInt(y.year)||0)); return a; }
    function buildDropSlots(session, sortedTimeline){ const gaps=[]; const n=sortedTimeline.length; for(let i=0;i<=n;i++){ const left=i===0?null:sortedTimeline[i-1]; const right=i===n?null:sortedTimeline[i]; gaps.push({left,right,index:i}); } return gaps; }
    function isPlacementCorrect(gap, yearNum){
      const y = parseInt(yearNum)||0; const ly = gap.left ? (parseInt(gap.left.year)||0) : null; const ry = gap.right ? (parseInt(gap.right.year)||0) : null;
      if (ly!==null && ry!==null && ly===ry) return y===ly;
      const leftOK = (ly===null) || (y>=ly); const rightOK=(ry===null)||(y<=ry); return leftOK && rightOK;
    }

    async function confirmPlacementHandler(){
      const sid = window.sessionId;
      const sSnap = await get(ref(db, `sessions/${sid}`)); if (!sSnap.exists()) return;
      const sess = sSnap.val();

      const { activeTid, activeTeam } = getActiveTeamInfo(sess);
      const cur = sess.current;
      if (!cur || !cur.trackId) return alert("Ingen lÃ¥t att placera.");
      if (selectedSlotIndex == null) return alert("VÃ¤lj en plats pÃ¥ tidslinjen fÃ¶rst.");

      const songMeta = sess.songMap?.[cur.trackId] || { year: "" };
      const songYear = parseInt(songMeta.year)||0;

      const sortedTL = sortTimelineByYear(activeTeam?.timeline || []);
      const gaps = buildDropSlots(sess, sortedTL);
      const chosenGap = gaps.find(g => g.index === selectedSlotIndex);
      if (!chosenGap) return alert("Ogiltig slot.");

      const correct = isPlacementCorrect(chosenGap, songYear);
      const newTL = (activeTeam.timeline || []).slice(); newTL.push({ trackId: cur.trackId, year: songMeta.year });

      const deck = sess.deck || []; const shown = sess.shown || {};
      const nextId = deck.find(id => !shown[id] && id !== cur.trackId);

      const updates = {}; const teamPath = `sessions/${sid}/teams/${activeTid}`;
      if (correct) updates[`${teamPath}/score`] = (activeTeam.score || 0) + 1;
      updates[`${teamPath}/timeline`] = newTL;
      updates[`sessions/${sid}/shown/${cur.trackId}`] = true;

      const order = sess.turn.order || []; const nextIdx = (sess.turn.activeIndex + 1) % (order.length || 1);
      updates[`sessions/${sid}/turn/activeIndex`] = nextIdx;

      if (nextId) {
        await update(ref(db, `sessions/${sid}/current`), { revealed: true });
        updates[`sessions/${sid}/current`] = { trackId: nextId, revealed: false };
        await update(ref(db), updates);
      } else {
        await update(ref(db, `sessions/${sid}/current`), { revealed: true });
        updates[`sessions/${sid}/status`] = "finished";
        await update(ref(db), updates);
      }
    }

    async function hostNextSong(){
      const sid = window.sessionId;
      const sSnap = await get(ref(db, `sessions/${sid}`)); if (!sSnap.exists()) return;
      const sess = sSnap.val();
      const deck = sess.deck || []; const shown = sess.shown || {};
      const nextId = deck.find(id => !shown[id]);
      const order = sess.turn.order;
      const nextIdx = (sess.turn.activeIndex + 1) % order.length;
      const updates = {};
      if (nextId){ updates[`sessions/${sid}/current`] = { trackId: nextId, revealed: false }; updates[`sessions/${sid}/shown/${nextId}`] = true; }
      else { updates[`sessions/${sid}/status`] = "finished"; }
      updates[`sessions/${sid}/turn/activeIndex`] = nextIdx;
      await update(ref(db), updates);
    }

    /* Start-knapp */
    async function onStartGame(){
      if (!document.querySelectorAll("input[name='source']:checked").length){
        const alla = document.getElementById("source-alla");
        if (alla) alla.checked = true;
      }
      window.updateYearSelection?.();
      if (!window.filterSongs()) return;

      try{
        const sid = await createSessionFromFilter();
        showLobby(sid);
      }catch(e){
        console.error(e);
        if (String(e).includes("PERMISSION_DENIED")) alert("BehÃ¶righetsfel i RTDB (sessions/*).");
        else alert("Kunde inte skapa session. Ã„r du inloggad? Finns lÃ¥tar i urvalet?");
      }
    }
    document.getElementById("startButton").addEventListener("click", onStartGame);

    /* Join frÃ¥n URL */
    maybeAutoJoinFromURL();

    // PWA SW
    if ("serviceWorker" in navigator) navigator.serviceWorker.register("/service-worker.js").catch(()=>{});
    
  </script>
</body>
</html>