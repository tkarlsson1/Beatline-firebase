
<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="description" content="Ã…rsquiz om lÃ¥tar â€“ multiplayer tidslinje.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NOTESTREAM â€“0.615 (TEST)</title>

  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;700&display=swap" rel="stylesheet" />
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111111">

  <!-- QR code lib -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

  <style>
    :root {
      --bg: #0b0f12;
      --txt: #fff;
      --card-w: 96px;
      --card-scale: 0.56;
      --gap: 10px;
      --team1: #ffcc00;
      --team2: #00a0ff;
      --team3: #ff4d5a;
    }
    html, body { margin:0; height:100%; background: var(--bg); color: var(--txt); font-family: 'Manrope', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { display:flex; flex-direction:column; align-items:center; }
    .container { padding: 14px; max-width: 960px; width: 100%; position: relative; z-index: 1; }

    select, button { padding: .5rem; font-size:1rem; margin-bottom:1rem; background:#032934; color:#fff; border:none; border-radius:8px; font-family:'Manrope', sans-serif; }
    .start-button { background: linear-gradient(to right, #fb1820, #ff6310); border: none; border-radius: 10px; padding: 12px 24px; font-size: 18px; font-weight: bold; color: white; cursor: pointer; transition: all .2s; display:block; margin:0 auto; }
    .start-button:hover { transform: scale(1.03); }
    .qrcode { width:160px; height:160px; border:5px solid black; border-radius:10px; display:block; margin:0 auto 1rem auto; }

    #envBadge { position: fixed; bottom: 8px; right: 8px; background: rgba(0,0,0,.7); color: #fff; padding: 6px 10px; border-radius: 8px; font-size: 12px; z-index: 9999; pointer-events: none; }

    /* Prototype-style timeline */
    .panel { background: rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:12px; }
    .row { display:flex; justify-content:center; align-items:center; margin-bottom:8px; gap:8px; flex-wrap:wrap; }
    .timeline-wrap { overflow:auto; }
    .timeline { display:flex; align-items:center; gap: 0; padding: 8px; justify-content: center; }
    .card { width: calc(var(--card-w)*var(--card-scale)); height: calc(var(--card-w)*var(--card-scale)*1.5); background:#111; border:1px solid rgba(255,255,255,.15); border-radius:12px; display:flex; align-items:center; justify-content:center; box-shadow: 0 4px 10px rgba(0,0,0,.25); position: relative; }
    .card .year-vert { transform: rotate(90deg); transform-origin:center; font-weight:700; letter-spacing:.35px; font-size: calc(var(--card-w)*var(--card-scale) * 0.58); line-height: 1; white-space: nowrap; }

    .ghost-gap { width: var(--gap); height: calc(var(--card-w)*var(--card-scale)*1.5); display:flex; align-items:center; justify-content:center; position:relative; transition: width .12s ease; flex: 0 0 auto; border: 2px dashed rgba(255,255,255,.22); border-radius:10px; opacity:.7; }
    .ghost-gap.active { width: calc(var(--card-w)*var(--card-scale)); border-color:#ffd166; background: rgba(255,209,102,.14); }

    .draggable { touch-action:none; user-select:none; -webkit-user-select:none; cursor: grab; }
    .draggable:active { cursor: grabbing; }

    .teams-strip { display:flex; justify-content:center; gap:14px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }
    .chip { display:flex; align-items:center; gap:6px; padding:.25rem .6rem; border:1px solid rgba(255,255,255,.2); border-radius:999px; background:rgba(255,255,255,.05); }
    .dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
    .t1 { background: var(--team1); } .t2 { background: var(--team2); } .t3 { background: var(--team3); }

    .center-controls { display:flex; justify-content:center; gap:10px; flex-wrap:wrap; align-items:center; margin-top:8px; }
    .answer-button { padding:.55rem .9rem; border-radius:8px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.06); color:#fff; cursor:pointer; }
    .answer-button:hover { background: rgba(255,255,255,.12); }

    .modal { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; justify-content:center; align-items:center; z-index:5000; }
    .modal-content { background:#fff; padding:1.5rem; border-radius:8px; width:min(92vw, 600px); max-height:80vh; overflow:auto; box-sizing:border-box; }
    .closeBtn { color:#333; font-weight:bold; cursor:pointer; font-size:1.5rem; position:absolute; top:10px; right:20px; }
  </style>
</head>

<body>
  <div id="envBadge"></div>

  <!-- Inloggningsmodal -->
  <div id="loginModal" class="modal" role="dialog" aria-modal="true">
    <div class="modal-content" style="text-align:center;">
      <span class="closeBtn" id="loginClose">&times;</span>
      <h2>Logga in</h2>
      <input type="email" id="emailInput" placeholder="Eâ€‘post" style="width:80%;padding:.5rem;margin:.3rem auto;display:block;" />
      <input type="password" id="passwordInput" placeholder="LÃ¶senord" style="width:80%;padding:.5rem;margin:.3rem auto;display:block;" />
      <button id="loginButton">Logga in</button>
      <button id="showRegister" style="margin-top: .8rem;">Skapa konto</button>
    </div>
  </div>

  <!-- Registreringsmodal -->
  <div id="registerModal" class="modal" role="dialog" aria-modal="true">
    <div class="modal-content" style="text-align:center;">
      <span class="closeBtn" id="registerClose">&times;</span>
      <h2>Registrera dig</h2>
      <input type="email" id="regEmail" placeholder="Eâ€‘post" style="width:80%;padding:.5rem;margin:.3rem auto;display:block;" />
      <input type="password" id="regPassword" placeholder="LÃ¶senord" style="width:80%;padding:.5rem;margin:.3rem auto;display:block;" />
      <button id="registerButton">Registrera</button>
    </div>
  </div>

  <div class="container">
    <!-- Startsida -->
    <div id="filter-page">
      <div id="source-checkbox-container" style="display:flex;flex-wrap:wrap;gap:10px;color:#fff;"></div>
      <div style="display:flex; justify-content:center; gap:1rem;">
        <div style="display:flex; flex-direction:column; align-items:center;">
          <label for="startYear">FrÃ¥n Ã¥r</label>
          <select id="startYear"></select>
        </div>
        <div style="display:flex; flex-direction:column; align-items:center;">
          <label for="endYear">Till Ã¥r</label>
          <select id="endYear"></select>
        </div>
      </div>

      <p id="selectedSongCount" style="text-align:center;">Valda lÃ¥tar: 0</p>
      <button id="startButton" class="start-button">Starta spel</button>
    </div>

    <!-- Lobby -->
    <div id="lobby-page" style="display:none; text-align:center;">
      <h2>Lobby</h2>
      <div id="lobby-qr" class="qrcode" aria-label="QR-kod fÃ¶r att gÃ¥ med"></div>
      <p id="lobby-link" style="font-size:.9rem; word-break:break-all;"></p>
      <h3>Lag</h3>
      <div id="team-list" style="max-width:480px; margin:0 auto;"></div>
      <button id="startGameButton" class="start-button" style="margin-top:1rem;">Starta spel</button>
    </div>

    <!-- Join -->
    <div id="join-page" style="display:none; text-align:center;">
      <h2>GÃ¥ med i spel</h2>
      <input id="joinTeamName" type="text" placeholder="Lagnamn" style="width:60%; padding:.5rem; margin:.5rem auto; background:#032934; color:#fff; border:0; border-radius:6px;">
      <button id="joinSubmit" class="start-button">GÃ¥ med</button>
    </div>

    <!-- Game -->
    <div id="game-page" style="display:none;">
      <div class="teams-strip" id="teams-header"></div>

      <div class="panel">
        <div class="timeline-wrap">
          <div class="timeline" id="activeTimeline"></div>
        </div>

        <div class="center-controls">
          <div id="songCard" class="chip draggable" aria-label="Dra fÃ¶r att lÃ¤gga kort">
            ðŸŽµ Dra fÃ¶r att lÃ¤gga kort
          </div>
        </div>

        <div class="center-controls">
          <button id="btnLock" class="answer-button" disabled>LÃ¥s in</button>
          <button id="revealButton" class="answer-button">Visa svar</button>
          <button id="confirmPlacementButton" class="answer-button">BekrÃ¤fta placering</button>
          <button id="nextSongButtonGame" class="answer-button">NÃ¤sta lÃ¥t</button>
        </div>
      </div>

      <div class="panel">
        <div class="timeline-wrap">
          <div class="timeline" id="miniTimeline"></div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    /* Firebase */
    import { initializeApp, getApp, getApps } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-app.js";
    import { getDatabase, ref, onValue, set, push, update, get } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-database.js";
    import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAfv4yGrI7Vj5PaX0A_XFRn0P4U--S9tFA",
      authDomain: "beatlinefirebase.firebaseapp.com",
      databaseURL: "https://notestreamfire.europe-west1.firebasedatabase.app",
      projectId: "beatlinefirebase",
      storageBucket: "beatlinefirebase.firebasestorage.app",
      messagingSenderId: "196231817325",
      appId: "1:196231817325:web:d5603a36a9c2c5f247f764"
    };
    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const db  = getDatabase(app, "https://notestreamfire.europe-west1.firebasedatabase.app");
    const auth = getAuth(app);
    document.getElementById("envBadge").textContent = `RTDB: https://notestreamfire.europe-west1.firebasedatabase.app`;

    /* State */
    let standardSongs = [], userPlaylistSongs = [], songs = [], sourceFilteredSongs = [], currentFilteredSongs = [], shownSongs = [];
    window.isHost = false; window.sessionId = null;
    let selectedSlotIndex = null;
    let dragging = false, activePointerId = null, currentHoverIndex = null;

    function setPage(id){
      ["filter-page","lobby-page","join-page","game-page"].forEach(pid=>{
        const el = document.getElementById(pid);
        if (el) el.style.display = (pid===id) ? "block" : "none";
      });
    }

    function joinURL(sessionId){
      const url = new URL(location.href);
      url.searchParams.set("join", sessionId);
      return url.origin + url.pathname + "?" + url.searchParams.toString();
    }

    function currentStartEndYears(){
      const s = document.getElementById("startYear"); const e = document.getElementById("endYear");
      return { startYear: parseInt(s.value)||1950, endYear: parseInt(e.value)||new Date().getFullYear() };
    }

    /* Auth */
    const $ = (id)=>document.getElementById(id);
    function show(el){ el.style.display='flex'; } function hide(el){ el.style.display='none'; }
    onAuthStateChanged(auth, (user)=>{
      if (user){ hide($("loginModal")); hide($("registerModal")); initDataListeners(); maybeAutoJoinFromURL(); }
      else { show($("loginModal")); }
    });
    $("loginButton").addEventListener("click", ()=>{
      const email = $("emailInput").value.trim(); const password = $("passwordInput").value;
      signInWithEmailAndPassword(auth, email, password).catch(()=>{});
    });
    $("registerButton").addEventListener("click", ()=>{
      const email = $("regEmail").value.trim(); const password = $("regPassword").value;
      createUserWithEmailAndPassword(auth, email, password).catch(()=>{});
    });
    $("loginClose").addEventListener("click", ()=> hide($("loginModal")));
    $("registerClose").addEventListener("click", ()=> hide($("registerModal")));
    $("showRegister").addEventListener("click", ()=>{ hide($("loginModal")); show($("registerModal")); });

    /* Data listeners */
    function initDataListeners(){
      onValue(ref(db, 'standardLists'), (snapshot)=>{
        standardSongs = [];
        if (snapshot.exists()) {
          const raw = snapshot.val();
          for (const playlistName in raw) {
            const playlistData = raw[playlistName];
            if (playlistData.songs) {
              for (const trackId in playlistData.songs) {
                standardSongs.push({ qr: trackId, ...playlistData.songs[trackId], source: [playlistName] });
              }
            }
          }
        }
        mergeSongs();
      });

      onAuthStateChanged(auth, (user)=>{
        if (!user) return;
        const uid = user.uid;
        onValue(ref(db, `userPlaylists/${uid}`), (snap)=>{
          userPlaylistSongs = [];
          if (snap.exists()) {
            const data = snap.val();
            for (const playlistName in data) {
              const pl = data[playlistName];
              if (pl.songs) {
                for (const trackId in pl.songs) {
                  userPlaylistSongs.push({ qr: trackId, ...pl.songs[trackId], source: [playlistName] });
                }
              }
            }
          }
          mergeSongs();
        });
      });
    }

    function mergeSongs(){
      const merged = {};
      standardSongs.forEach(s => { merged[s.qr] = { ...s, source:[...s.source] }; });
      userPlaylistSongs.forEach(s => {
        if (merged[s.qr]) merged[s.qr].source = [...new Set([...merged[s.qr].source, ...s.source])];
        else merged[s.qr] = { ...s, year: s.customYear ?? s.year, source:[...s.source] };
      });
      songs = Object.values(merged);
      populateSourceCheckboxes();
    }

    function populateSourceCheckboxes(){
      const container = $("source-checkbox-container"); container.innerHTML = "";
      const allDiv = document.createElement("div"); const cbAll = document.createElement("input"); cbAll.type="checkbox"; cbAll.name="source"; cbAll.value="alla"; cbAll.id="source-alla";
      const lbAll = document.createElement("label"); lbAll.htmlFor="source-alla"; lbAll.textContent="Alla lÃ¥tar";
      allDiv.appendChild(cbAll); allDiv.appendChild(lbAll); container.appendChild(allDiv);

      const stdSources = Array.from(new Set(standardSongs.map(s => s.source[0]))).sort();
      stdSources.forEach(src=>{
        const w = document.createElement("div"); const cb=document.createElement("input"); cb.type="checkbox"; cb.name="source"; cb.value=src; cb.id="std-"+src.replace(/\s+/g,'-');
        const lb=document.createElement("label"); lb.htmlFor=cb.id; lb.textContent=src; w.appendChild(cb); w.appendChild(lb); container.appendChild(w);
      });
      const usrSources = Array.from(new Set(userPlaylistSongs.map(s => s.source[0]))).filter(x=>!stdSources.includes(x)).sort();
      usrSources.forEach(src=>{
        const w = document.createElement("div"); const cb=document.createElement("input"); cb.type="checkbox"; cb.name="source"; cb.value=src; cb.id="usr-"+src.replace(/\s+/g,'-');
        const lb=document.createElement("label"); lb.htmlFor=cb.id; lb.textContent=src; w.appendChild(cb); w.appendChild(lb); container.appendChild(w);
      });

      const startDD = $("startYear"), endDD = $("endYear"); startDD.innerHTML=""; endDD.innerHTML="";
      const thisYear = new Date().getFullYear();
      for (let y=1950; y<=thisYear; y++){ const o1=document.createElement("option"); o1.value=y; o1.textContent=y; if (y===1950) o1.selected=true; startDD.appendChild(o1);
                                          const o2=document.createElement("option"); o2.value=y; o2.textContent=y; if (y===thisYear) o2.selected=true; endDD.appendChild(o2); }
      updateSongCount();
    }

    function updateSongCount(){
      const startYear = parseInt($("startYear").value); const endYear = parseInt($("endYear").value);
      const cnt = sourceFilteredSongs.filter(s => +s.year >= startYear && +s.year <= endYear).length;
      $("selectedSongCount").textContent = `Valda lÃ¥tar: ${cnt}`;
    }

    window.updateYearSelection = function(){
      const checked = Array.from(document.querySelectorAll('input[name="source"]:checked')).map(x => x.value);
      let selected = checked.includes("alla")
        ? Array.from(new Set([...new Set(standardSongs.map(s=>s.source[0])), ...new Set(userPlaylistSongs.map(s=>s.source[0])), "alla"]))
        : checked;
      sourceFilteredSongs = songs.filter(song => song.source.some(src => selected.includes(src)));
      updateSongCount();
    };

    window.filterSongs = function(){
      const startYear = parseInt($("startYear").value), endYear = parseInt($("endYear").value);
      currentFilteredSongs = sourceFilteredSongs.filter(s => +s.year >= startYear && +s.year <= endYear);
      shownSongs = [];
      if (!currentFilteredSongs.length){ alert("Inga lÃ¥tar i intervallet."); return false; }
      return true;
    };

    /* Lobby / Session */
    async function createSessionFromFilter(){
      if (!auth.currentUser) throw new Error("Inte inloggad.");
      const list = window.currentFilteredSongs || [];
      if (!list.length) throw new Error("Inga filtrerade lÃ¥tar.");
      const {startYear, endYear} = currentStartEndYears();

      const deck = list.map(s=>s.qr);
      const songMap = {}; list.forEach(s=>{ const yr=s.customYear??s.year; songMap[s.qr] = { title:s.title||"", artist:s.artist||"", year: yr||"" }; });

      const sessionRef = push(ref(db, 'sessions')); const sid = sessionRef.key;
      await set(sessionRef, {
        createdAt: Date.now(), status:"lobby", hostId: auth.currentUser.uid,
        settings:{ startYear, endYear }, songMap, deck, shown:{}, current:null,
        teams:{}, turn:{ order:[], activeIndex:0 }
      });
      window.sessionId = sid; window.isHost = true; localStorage.setItem("sessionId", sid); localStorage.setItem("role","host");
      return sid;
    }

    function renderLobbyTeams(session){
      const list = $("team-list"); list.innerHTML="";
      const teams = session.teams ? Object.entries(session.teams) : [];
      if (!teams.length) list.innerHTML="<p>Inga lag Ã¤nnu â€“ scanna QR.</p>";
      teams.forEach(([tid,t])=>{ const item=document.createElement("div"); item.style.padding=".4rem"; item.style.background="rgba(255,255,255,.06)"; item.style.borderRadius="8px"; item.textContent=`${t.name} â€¢ ${t.score||0}p`; list.appendChild(item); });
    }

    function listenToSession(sid){
      onValue(ref(db, `sessions/${sid}`), snap => {
        if (!snap.exists()) return;
        const session = snap.val();
        renderLobbyTeams(session);
        if (session.status === "lobby"){ setPage("lobby-page"); }
        else { renderGame(session); setPage("game-page"); }
      });
    }

    function showLobby(sid){
      setPage("lobby-page"); window.sessionId=sid; window.isHost=true;
      const q = $("lobby-qr"); q.innerHTML=""; new QRCode(q, { text: joinURL(sid), width:160, height:160 });
      $("lobby-link").textContent = joinURL(sid);
      const btn = $("startGameButton");
      if (!btn._bound){ btn._bound=true; btn.addEventListener("click", async ()=>{ try{ await startGameHost(); }catch(e){ alert("Kunde inte starta spelet."); } }); }
      listenToSession(sid);
    }

    function showJoinPage(sid){
      setPage("join-page"); window.sessionId=sid; window.isHost=false; localStorage.setItem("role","player");
      const btn = $("joinSubmit");
      if (!btn._bound){ btn._bound=true; btn.addEventListener("click", async ()=>{
        const name = ($("joinTeamName").value||"").trim(); if (!name) return alert("Ange lagnamn.");
        const teamRef = push(ref(db, `sessions/${sid}/teams`)); const teamId = teamRef.key;
        await set(teamRef, { name, tokens: 3, score: 0, timeline: [] }); localStorage.setItem("teamId", teamId); listenToSession(sid);
      });}
    }

    function maybeAutoJoinFromURL(){
      const p = new URLSearchParams(location.search); const sid = p.get("join"); if (!sid) return;
      if (localStorage.getItem("sessionId") === sid){ listenToSession(sid); return; } showJoinPage(sid);
    }

    async function startGameHost(){
      const sid = window.sessionId;
      const teamsSnap = await get(ref(db, `sessions/${sid}/teams`)); const teams = teamsSnap.val() || {}; const order = Object.keys(teams);
      if (!order.length) return alert("Minst ett lag krÃ¤vs.");
      const sessSnap = await get(ref(db, `sessions/${sid}`)); const sess = sessSnap.val(); const deck = sess.deck || []; const shown = sess.shown || {};
      const nextId = deck.find(id => !shown[id]); if (!nextId) return alert("Deck tomt.");
      const updates = {}; updates[`sessions/${sid}/status`] = "playing"; updates[`sessions/${sid}/turn`] = { order, activeIndex: 0 }; updates[`sessions/${sid}/current`] = { trackId: nextId, revealed: false }; updates[`sessions/${sid}/shown/${nextId}`] = true;
      await update(ref(db), updates);
    }

    /* ===== Game UI (prototype-style) ===== */
    function yearsForTeam(session, tid){
      const t = session.teams?.[tid]; const arr = (t?.timeline||[]).map(x => parseInt(x.year)||0).filter(Boolean);
      return arr.slice().sort((a,b)=>a-b);
    }
    function orderFor(session){ return (session.turn && session.turn.order) || Object.keys(session.teams||{}); }
    function activeIdxFor(session){ return (session.turn && typeof session.turn.activeIndex==='number') ? session.turn.activeIndex : 0; }
    function activeTidFor(session){ const ord=orderFor(session); return ord[activeIdxFor(session)] || null; }

    function computeCardLayout(container){
      const wrap = container.closest('.timeline-wrap'); if (!wrap) return;
      const w = wrap.clientWidth || window.innerWidth; const padding = 24;
      const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-scale')) || 0.56;
      const maxBase = 140, minBase = 56;
      let bestBase = 96, bestGap = 10;
      for (let base=maxBase; base>=minBase; base--){
        const cw = base * scale, gap = Math.max(6, Math.round(cw*0.12));
        const total = 10*cw + 11*gap; // heuristik
        if (total <= (w - padding)) { bestBase = base; bestGap = gap; break; }
      }
      document.documentElement.style.setProperty('--card-w', bestBase + 'px');
      document.documentElement.style.setProperty('--gap', bestGap + 'px');
    }

    function makeCard(year){
      const d = document.createElement('div'); d.className = 'card';
      const lab = document.createElement('div'); lab.className='year-vert'; lab.textContent = year; d.appendChild(lab);
      return d;
    }
    function makeGap(i){
      const g = document.createElement('div'); g.className='ghost-gap'; g.dataset.slotIndex=i;
      if (i === currentHoverIndex) g.classList.add('active');
      return g;
    }

    function renderTeamsHeader(session){
      const wrap = $("teams-header"); wrap.innerHTML="";
      const ord = orderFor(session); const actIdx = activeIdxFor(session);
      ord.forEach((tid, idx)=>{
        const t = session.teams[tid];
        const chip = document.createElement("div"); chip.className="chip"; chip.style.background = idx===actIdx ? "rgba(11,147,156,.65)" : "rgba(255,255,255,.05)";
        const dot = document.createElement("span"); dot.className="dot " + (idx===0?'t1':idx===1?'t2':'t3');
        const label = document.createElement("span"); label.textContent = `${t.name} â€¢ ${t.score||0}p â€¢ ðŸ”¥${t.tokens??3}`;
        chip.appendChild(dot); chip.appendChild(label); wrap.appendChild(chip);
      });
    }

    function renderTimelines(session){
      const actTid = activeTidFor(session); if (!actTid) return;
      const ys = yearsForTeam(session, actTid);
      const activeContainer = $("activeTimeline"), miniContainer = $("miniTimeline");
      computeCardLayout(activeContainer); computeCardLayout(miniContainer);

      // Active
      activeContainer.innerHTML="";
      for (let i=0;i<=ys.length;i++){
        activeContainer.appendChild(makeGap(i));
        if (i<ys.length) activeContainer.appendChild(makeCard(String(ys[i])));
      }

      // Mini = nÃ¤sta lags timeline
      miniContainer.innerHTML="";
      const ord = orderFor(session); const nextIdx = (activeIdxFor(session)+1) % ord.length; const nextTid = ord[nextIdx];
      const ysNext = yearsForTeam(session, nextTid);
      for (let i=0;i<=ysNext.length;i++){
        miniContainer.appendChild(makeGap(-1)); // passiv, ej interaktiv
        if (i<ysNext.length) miniContainer.appendChild(makeCard(String(ysNext[i])));
      }
    }

    function renderGame(session){
      renderTeamsHeader(session);
      renderTimelines(session);
      wireGameControls(session);
    }

    function nearestIndexByMidpoint(container, x){
      const gaps = Array.from(container.querySelectorAll('.ghost-gap'));
      let bestIdx=null, bestDist=Infinity;
      gaps.forEach((g,i)=>{
        const r = g.getBoundingClientRect(); const cx = r.left + r.width/2; const d = Math.abs(x - cx);
        if (d < bestDist){ bestDist=d; bestIdx=i; }
      });
      return bestIdx;
    }

    function wireGameControls(session){
      const isHost = (window.isHost === true);
      const activeContainer = $("activeTimeline");
      const songCard = $("songCard");
      const btnLock = $("btnLock");
      const revealBtn = $("revealButton");
      const confirmBtn = $("confirmPlacementButton");
      const nextBtn = $("nextSongButtonGame");

      btnLock.disabled = (selectedSlotIndex===null);

      if (isHost){
        // Drag via pointer events
        function startDrag(e){
          dragging=true; activePointerId = e.pointerId;
          try { e.target.setPointerCapture && e.target.setPointerCapture(activePointerId); } catch(_){}
          window.addEventListener('pointermove', onMove);
          window.addEventListener('pointerup', endDrag, { once:true });
          window.addEventListener('pointercancel', cancelDrag, { once:true });
          onMove(e);
        }
        function onMove(e){
          if (!dragging || e.pointerId!==activePointerId) return;
          const x = e.clientX; const idx = nearestIndexByMidpoint(activeContainer, x);
          if (idx!==null){ currentHoverIndex = idx; selectedSlotIndex = idx; btnLock.disabled = false; renderTimelines(session); }
        }
        function endDrag(_e){ dragging=false; activePointerId=null; }
        function cancelDrag(_e){ dragging=false; activePointerId=null; }

        songCard.onpointerdown = startDrag;
        activeContainer.onpointermove = (e)=>{ if (dragging) onMove(e); };

        btnLock.onclick = async ()=>{
          // simply call confirmPlacement to commit slot against DB logic
          await confirmPlacementHandler();
          // reset UI state
          selectedSlotIndex = null; currentHoverIndex = null; btnLock.disabled = true;
        };
        revealBtn.onclick = async ()=>{
          const sid = window.sessionId; const curSnap = await get(ref(db, `sessions/${sid}/current`)); if (!curSnap.exists()) return;
          await update(ref(db, `sessions/${sid}/current`), { revealed: true });
        };
        confirmBtn.onclick = async ()=>{
          await confirmPlacementHandler();
          selectedSlotIndex = null; currentHoverIndex = null; btnLock.disabled = true;
        };
        nextBtn.onclick = hostNextSong;
      } else {
        songCard.onpointerdown = null; btnLock.disabled = true;
        revealBtn.onclick = null; confirmBtn.onclick = null; nextBtn.onclick = null;
      }
    }

    /* Helpers used by confirmPlacementHandler */
    function getActiveTeamInfo(session){
      const order = (session.turn && session.turn.order) || [];
      const idx = (session.turn && typeof session.turn.activeIndex === 'number') ? session.turn.activeIndex : 0;
      const activeTid = order[idx];
      const activeTeam = activeTid ? session.teams?.[activeTid] : null;
      return { activeTid, activeTeam, activeIndex: idx };
    }
    function sortTimelineByYear(tl){ const a=(tl||[]).slice(); a.sort((x,y)=>(parseInt(x.year)||0)-(parseInt(y.year)||0)); return a; }
    function buildDropSlots(session, sortedTimeline){ const gaps=[]; const n=sortedTimeline.length; for(let i=0;i<=n;i++){ const left=i===0?null:sortedTimeline[i-1]; const right=i===n?null:sortedTimeline[i]; gaps.push({left,right,index:i}); } return gaps; }
    function isPlacementCorrect(gap, yearNum){
      const y = parseInt(yearNum)||0; const ly = gap.left ? (parseInt(gap.left.year)||0) : null; const ry = gap.right ? (parseInt(gap.right.year)||0) : null;
      if (ly!==null && ry!==null && ly===ry) return y===ly;
      const leftOK = (ly===null) || (y>=ly); const rightOK=(ry===null)||(y<=ry); return leftOK && rightOK;
    }

    async function confirmPlacementHandler(){
      const sid = window.sessionId;
      const sSnap = await get(ref(db, `sessions/${sid}`)); if (!sSnap.exists()) return;
      const sess = sSnap.val();

      const { activeTid, activeTeam } = getActiveTeamInfo(sess);
      const cur = sess.current;
      if (!cur || !cur.trackId) return alert("Ingen lÃ¥t att placera.");
      if (selectedSlotIndex == null) return alert("VÃ¤lj en plats pÃ¥ tidslinjen fÃ¶rst.");

      const songMeta = sess.songMap?.[cur.trackId] || { year: "" };
      const songYear = parseInt(songMeta.year)||0;

      const sortedTL = sortTimelineByYear(activeTeam?.timeline || []);
      const gaps = buildDropSlots(sess, sortedTL);
      const chosenGap = gaps.find(g => g.index === selectedSlotIndex);
      if (!chosenGap) return alert("Ogiltig slot.");

      const correct = isPlacementCorrect(chosenGap, songYear);
      const newTL = (activeTeam.timeline || []).slice(); newTL.push({ trackId: cur.trackId, year: songMeta.year });

      const deck = sess.deck || []; const shown = sess.shown || {};
      const nextId = deck.find(id => !shown[id] && id !== cur.trackId);

      const updates = {}; const teamPath = `sessions/${sid}/teams/${activeTid}`;
      if (correct) updates[`${teamPath}/score`] = (activeTeam.score || 0) + 1;
      updates[`${teamPath}/timeline`] = newTL;
      updates[`sessions/${sid}/shown/${cur.trackId}`] = true;

      const order = sess.turn.order || []; const nextIdx = (sess.turn.activeIndex + 1) % (order.length || 1);
      updates[`sessions/${sid}/turn/activeIndex`] = nextIdx;

      if (nextId) {
        await update(ref(db, `sessions/${sid}/current`), { revealed: true });
        updates[`sessions/${sid}/current`] = { trackId: nextId, revealed: false };
        await update(ref(db), updates);
      } else {
        await update(ref(db, `sessions/${sid}/current`), { revealed: true });
        updates[`sessions/${sid}/status`] = "finished";
        await update(ref(db), updates);
      }
    }

    async function hostNextSong(){
      const sid = window.sessionId;
      const sSnap = await get(ref(db, `sessions/${sid}`)); if (!snap) return;
      const sess = sSnap.val();
      const deck = sess.deck || []; const shown = sess.shown || {};
      const nextId = deck.find(id => !shown[id]);
      const order = sess.turn.order;
      const nextIdx = (sess.turn.activeIndex + 1) % order.length;
      const updates = {};
      if (nextId){ updates[`sessions/${sid}/current`] = { trackId: nextId, revealed: false }; updates[`sessions/${sid}/shown/${nextId}`] = true; }
      else { updates[`sessions/${sid}/status`] = "finished"; }
      updates[`sessions/${sid}/turn/activeIndex`] = nextIdx;
      await update(ref(db), updates);
    }

    /* Start-knapp */
    async function onStartGame(){
      if (!document.querySelectorAll("input[name='source']:checked").length){
        const alla = document.getElementById("source-alla"); if (alla) alla.checked = true;
      }
      window.updateYearSelection?.();
      if (!window.filterSongs()) return;

      try{
        const sid = await createSessionFromFilter();
        showLobby(sid);
      }catch(e){
        console.error(e);
        if (String(e).includes("PERMISSION_DENIED")) alert("BehÃ¶righetsfel i RTDB (sessions/*).");
        else alert("Kunde inte skapa session. Ã„r du inloggad? Finns lÃ¥tar i urvalet?");
      }
    }
    document.getElementById("startButton").addEventListener("click", onStartGame);

    /* Join frÃ¥n URL */
    maybeAutoJoinFromURL();

    // PWA SW
    if ("serviceWorker" in navigator) navigator.serviceWorker.register("/service-worker.js").catch(()=>{});
  </script>
</body>
</html>
